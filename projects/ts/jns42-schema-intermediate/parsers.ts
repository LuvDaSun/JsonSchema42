// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.8.6                          -- www.JsonSchema42.org
export function parseSchemaJson(value: unknown): unknown {
return _parseMapSchemaJson(value);
}
function _parseMapSchemaJson(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "$schema": {
const propertyValue = parseSchema(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "schemas": {
const propertyValue = parseSchemas(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseNode(value: unknown): unknown {
return _parseMapNode(value);
}
function _parseMapNode(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "context": {
const propertyValue = parseContext(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "metadata": {
const propertyValue = parseMetadata(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "types": {
const propertyValue = parseTypes(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "assertions": {
const propertyValue = parseAssertions(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "applicators": {
const propertyValue = parseApplicators(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseMetadataSection(value: unknown): unknown {
return _parseMapMetadataSection(value);
}
function _parseMapMetadataSection(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "title": {
const propertyValue = parseTitle(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "description": {
const propertyValue = parseDescription(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "examples": {
const propertyValue = parseExamples(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "deprecated": {
const propertyValue = parseDeprecated(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseTypesSection(value: unknown): unknown {
return _parseArrayTypesSection(value);
}
function _parseArrayTypesSection(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseTypesSectionItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseAssertionsSection(value: unknown): unknown {
return _parseMapAssertionsSection(value);
}
function _parseMapAssertionsSection(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "boolean": {
const propertyValue = parseBoolean(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "integer": {
const propertyValue = parseInteger(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "number": {
const propertyValue = parseNumber(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "string": {
const propertyValue = parseString(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "array": {
const propertyValue = parseArray(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "map": {
const propertyValue = parseMap(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseApplicatorsSection(value: unknown): unknown {
return _parseMapApplicatorsSection(value);
}
function _parseMapApplicatorsSection(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "reference": {
const propertyValue = parseReference(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "oneOf": {
const propertyValue = parseOneOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "anyOf": {
const propertyValue = parseAnyOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "allOf": {
const propertyValue = parseAllOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "if": {
const propertyValue = parseIf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "then": {
const propertyValue = parseThen(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "else": {
const propertyValue = parseElse(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "not": {
const propertyValue = parseNot(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "dependentSchemas": {
const propertyValue = parseDependentSchemas(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "objectProperties": {
const propertyValue = parseObjectProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "mapProperties": {
const propertyValue = parseMapProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "patternProperties": {
const propertyValue = parsePatternProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "propertyNames": {
const propertyValue = parsePropertyNames(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "tupleItems": {
const propertyValue = parseTupleItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "arrayItems": {
const propertyValue = parseArrayItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "contains": {
const propertyValue = parseContains(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseBooleanAssertion(value: unknown): unknown {
return _parseMapBooleanAssertion(value);
}
function _parseMapBooleanAssertion(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "options": {
const propertyValue = parseBooleanAssertionOptions(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseIntegerAssertion(value: unknown): unknown {
return _parseMapIntegerAssertion(value);
}
function _parseMapIntegerAssertion(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "options": {
const propertyValue = parseIntegerAssertionOptions(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minimumInclusive": {
const propertyValue = parseIntegerAssertionMinimumInclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minimumExclusive": {
const propertyValue = parseIntegerAssertionMinimumExclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximumInclusive": {
const propertyValue = parseIntegerAssertionMaximumInclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximumExclusive": {
const propertyValue = parseIntegerAssertionMaximumExclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "multipleOf": {
const propertyValue = parseIntegerAssertionMultipleOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseNumberAssertion(value: unknown): unknown {
return _parseMapNumberAssertion(value);
}
function _parseMapNumberAssertion(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "options": {
const propertyValue = parseNumberAssertionOptions(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minimumInclusive": {
const propertyValue = parseNumberAssertionMinimumInclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minimumExclusive": {
const propertyValue = parseNumberAssertionMinimumExclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximumInclusive": {
const propertyValue = parseNumberAssertionMaximumInclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximumExclusive": {
const propertyValue = parseNumberAssertionMaximumExclusive(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "multipleOf": {
const propertyValue = parseNumberAssertionMultipleOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseStringAssertion(value: unknown): unknown {
return _parseMapStringAssertion(value);
}
function _parseMapStringAssertion(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "options": {
const propertyValue = parseStringAssertionOptions(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minimumLength": {
const propertyValue = parseMinimumLength(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximumLength": {
const propertyValue = parseMaximumLength(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "valuePattern": {
const propertyValue = parseValuePattern(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "valueFormat": {
const propertyValue = parseValueFormat(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseArrayAssertion(value: unknown): unknown {
return _parseMapArrayAssertion(value);
}
function _parseMapArrayAssertion(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "minimumItems": {
const propertyValue = parseMinimumItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximumItems": {
const propertyValue = parseMaximumItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "uniqueItems": {
const propertyValue = parseUniqueItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseMapAssertion(value: unknown): unknown {
return _parseMapMapAssertion(value);
}
function _parseMapMapAssertion(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "required": {
const propertyValue = parseRequired(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minimumProperties": {
const propertyValue = parseMinimumProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximumProperties": {
const propertyValue = parseMaximumProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
export function parseNodeReference(value: unknown): unknown {
return _parseStringNodeReference(value);
}
function _parseStringNodeReference(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseIntegerValue(value: unknown): unknown {
return _parseIntegerIntegerValue(value);
}
function _parseIntegerIntegerValue(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseNumberValue(value: unknown): unknown {
return _parseNumberNumberValue(value);
}
function _parseNumberNumberValue(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseBooleanValue(value: unknown): unknown {
return _parseBooleanBooleanValue(value);
}
function _parseBooleanBooleanValue(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseStringValue(value: unknown): unknown {
return _parseStringStringValue(value);
}
function _parseStringStringValue(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseNonEmptyStringValue(value: unknown): unknown {
return _parseStringNonEmptyStringValue(value);
}
function _parseStringNonEmptyStringValue(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseAmount(value: unknown): unknown {
return _parseIntegerAmount(value);
}
function _parseIntegerAmount(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseSchema(value: unknown): unknown {
return _parseStringSchema(value);
}
function _parseStringSchema(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseSchemas(value: unknown): unknown {
return _parseMapSchemas(value);
}
function _parseMapSchemas(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseSchemasAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseContext(value: unknown): unknown {
return _parseReferenceContext(value);
}
function _parseReferenceContext(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseMetadata(value: unknown): unknown {
return _parseReferenceMetadata(value);
}
function _parseReferenceMetadata(value: unknown): unknown {
return parseMetadataSection(value);
}
export function parseTypes(value: unknown): unknown {
return _parseReferenceTypes(value);
}
function _parseReferenceTypes(value: unknown): unknown {
return parseTypesSection(value);
}
export function parseAssertions(value: unknown): unknown {
return _parseReferenceAssertions(value);
}
function _parseReferenceAssertions(value: unknown): unknown {
return parseAssertionsSection(value);
}
export function parseApplicators(value: unknown): unknown {
return _parseReferenceApplicators(value);
}
function _parseReferenceApplicators(value: unknown): unknown {
return parseApplicatorsSection(value);
}
export function parseTitle(value: unknown): unknown {
return _parseReferenceTitle(value);
}
function _parseReferenceTitle(value: unknown): unknown {
return parseNonEmptyStringValue(value);
}
export function parseDescription(value: unknown): unknown {
return _parseReferenceDescription(value);
}
function _parseReferenceDescription(value: unknown): unknown {
return parseNonEmptyStringValue(value);
}
export function parseExamples(value: unknown): unknown {
return _parseArrayExamples(value);
}
function _parseArrayExamples(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseExamplesItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseDeprecated(value: unknown): unknown {
return _parseReferenceDeprecated(value);
}
function _parseReferenceDeprecated(value: unknown): unknown {
return parseBooleanValue(value);
}
export function parseTypesSectionItems(value: unknown): unknown {
return _parseStringTypesSectionItems(value);
}
function _parseStringTypesSectionItems(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseBoolean(value: unknown): unknown {
return _parseReferenceBoolean(value);
}
function _parseReferenceBoolean(value: unknown): unknown {
return parseBooleanAssertion(value);
}
export function parseInteger(value: unknown): unknown {
return _parseReferenceInteger(value);
}
function _parseReferenceInteger(value: unknown): unknown {
return parseIntegerAssertion(value);
}
export function parseNumber(value: unknown): unknown {
return _parseReferenceNumber(value);
}
function _parseReferenceNumber(value: unknown): unknown {
return parseNumberAssertion(value);
}
export function parseString(value: unknown): unknown {
return _parseReferenceString(value);
}
function _parseReferenceString(value: unknown): unknown {
return parseStringAssertion(value);
}
export function parseArray(value: unknown): unknown {
return _parseReferenceArray(value);
}
function _parseReferenceArray(value: unknown): unknown {
return parseArrayAssertion(value);
}
export function parseMap(value: unknown): unknown {
return _parseReferenceMap(value);
}
function _parseReferenceMap(value: unknown): unknown {
return parseMapAssertion(value);
}
export function parseReference(value: unknown): unknown {
return _parseReferenceReference(value);
}
function _parseReferenceReference(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseOneOf(value: unknown): unknown {
return _parseArrayOneOf(value);
}
function _parseArrayOneOf(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseOneOfItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseAnyOf(value: unknown): unknown {
return _parseArrayAnyOf(value);
}
function _parseArrayAnyOf(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseAnyOfItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseAllOf(value: unknown): unknown {
return _parseArrayAllOf(value);
}
function _parseArrayAllOf(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseAllOfItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseIf(value: unknown): unknown {
return _parseReferenceIf(value);
}
function _parseReferenceIf(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseThen(value: unknown): unknown {
return _parseReferenceThen(value);
}
function _parseReferenceThen(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseElse(value: unknown): unknown {
return _parseReferenceElse(value);
}
function _parseReferenceElse(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseNot(value: unknown): unknown {
return _parseReferenceNot(value);
}
function _parseReferenceNot(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseDependentSchemas(value: unknown): unknown {
return _parseMapDependentSchemas(value);
}
function _parseMapDependentSchemas(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseDependentSchemasAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseObjectProperties(value: unknown): unknown {
return _parseMapObjectProperties(value);
}
function _parseMapObjectProperties(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseObjectPropertiesAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseMapProperties(value: unknown): unknown {
return _parseReferenceMapProperties(value);
}
function _parseReferenceMapProperties(value: unknown): unknown {
return parseNodeReference(value);
}
export function parsePatternProperties(value: unknown): unknown {
return _parseMapPatternProperties(value);
}
function _parseMapPatternProperties(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parsePatternPropertiesAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parsePropertyNames(value: unknown): unknown {
return _parseReferencePropertyNames(value);
}
function _parseReferencePropertyNames(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseTupleItems(value: unknown): unknown {
return _parseArrayTupleItems(value);
}
function _parseArrayTupleItems(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseTupleItemsItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseArrayItems(value: unknown): unknown {
return _parseReferenceArrayItems(value);
}
function _parseReferenceArrayItems(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseContains(value: unknown): unknown {
return _parseReferenceContains(value);
}
function _parseReferenceContains(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseBooleanAssertionOptions(value: unknown): unknown {
return _parseArrayBooleanAssertionOptions(value);
}
function _parseArrayBooleanAssertionOptions(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseBooleanAssertionOptionsItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseIntegerAssertionOptions(value: unknown): unknown {
return _parseArrayIntegerAssertionOptions(value);
}
function _parseArrayIntegerAssertionOptions(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseIntegerAssertionOptionsItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseIntegerAssertionMinimumInclusive(value: unknown): unknown {
return _parseReferenceIntegerAssertionMinimumInclusive(value);
}
function _parseReferenceIntegerAssertionMinimumInclusive(value: unknown): unknown {
return parseIntegerValue(value);
}
export function parseIntegerAssertionMinimumExclusive(value: unknown): unknown {
return _parseReferenceIntegerAssertionMinimumExclusive(value);
}
function _parseReferenceIntegerAssertionMinimumExclusive(value: unknown): unknown {
return parseIntegerValue(value);
}
export function parseIntegerAssertionMaximumInclusive(value: unknown): unknown {
return _parseReferenceIntegerAssertionMaximumInclusive(value);
}
function _parseReferenceIntegerAssertionMaximumInclusive(value: unknown): unknown {
return parseIntegerValue(value);
}
export function parseIntegerAssertionMaximumExclusive(value: unknown): unknown {
return _parseReferenceIntegerAssertionMaximumExclusive(value);
}
function _parseReferenceIntegerAssertionMaximumExclusive(value: unknown): unknown {
return parseIntegerValue(value);
}
export function parseIntegerAssertionMultipleOf(value: unknown): unknown {
return _parseReferenceIntegerAssertionMultipleOf(value);
}
function _parseReferenceIntegerAssertionMultipleOf(value: unknown): unknown {
return parseIntegerValue(value);
}
export function parseNumberAssertionOptions(value: unknown): unknown {
return _parseArrayNumberAssertionOptions(value);
}
function _parseArrayNumberAssertionOptions(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseNumberAssertionOptionsItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseNumberAssertionMinimumInclusive(value: unknown): unknown {
return _parseReferenceNumberAssertionMinimumInclusive(value);
}
function _parseReferenceNumberAssertionMinimumInclusive(value: unknown): unknown {
return parseNumberValue(value);
}
export function parseNumberAssertionMinimumExclusive(value: unknown): unknown {
return _parseReferenceNumberAssertionMinimumExclusive(value);
}
function _parseReferenceNumberAssertionMinimumExclusive(value: unknown): unknown {
return parseNumberValue(value);
}
export function parseNumberAssertionMaximumInclusive(value: unknown): unknown {
return _parseReferenceNumberAssertionMaximumInclusive(value);
}
function _parseReferenceNumberAssertionMaximumInclusive(value: unknown): unknown {
return parseNumberValue(value);
}
export function parseNumberAssertionMaximumExclusive(value: unknown): unknown {
return _parseReferenceNumberAssertionMaximumExclusive(value);
}
function _parseReferenceNumberAssertionMaximumExclusive(value: unknown): unknown {
return parseNumberValue(value);
}
export function parseNumberAssertionMultipleOf(value: unknown): unknown {
return _parseReferenceNumberAssertionMultipleOf(value);
}
function _parseReferenceNumberAssertionMultipleOf(value: unknown): unknown {
return parseNumberValue(value);
}
export function parseStringAssertionOptions(value: unknown): unknown {
return _parseArrayStringAssertionOptions(value);
}
function _parseArrayStringAssertionOptions(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseStringAssertionOptionsItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseMinimumLength(value: unknown): unknown {
return _parseReferenceMinimumLength(value);
}
function _parseReferenceMinimumLength(value: unknown): unknown {
return parseAmount(value);
}
export function parseMaximumLength(value: unknown): unknown {
return _parseReferenceMaximumLength(value);
}
function _parseReferenceMaximumLength(value: unknown): unknown {
return parseAmount(value);
}
export function parseValuePattern(value: unknown): unknown {
return _parseReferenceValuePattern(value);
}
function _parseReferenceValuePattern(value: unknown): unknown {
return parseNonEmptyStringValue(value);
}
export function parseValueFormat(value: unknown): unknown {
return _parseReferenceValueFormat(value);
}
function _parseReferenceValueFormat(value: unknown): unknown {
return parseNonEmptyStringValue(value);
}
export function parseMinimumItems(value: unknown): unknown {
return _parseReferenceMinimumItems(value);
}
function _parseReferenceMinimumItems(value: unknown): unknown {
return parseAmount(value);
}
export function parseMaximumItems(value: unknown): unknown {
return _parseReferenceMaximumItems(value);
}
function _parseReferenceMaximumItems(value: unknown): unknown {
return parseAmount(value);
}
export function parseUniqueItems(value: unknown): unknown {
return _parseBooleanUniqueItems(value);
}
function _parseBooleanUniqueItems(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseRequired(value: unknown): unknown {
return _parseArrayRequired(value);
}
function _parseArrayRequired(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseRequiredItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseMinimumProperties(value: unknown): unknown {
return _parseReferenceMinimumProperties(value);
}
function _parseReferenceMinimumProperties(value: unknown): unknown {
return parseAmount(value);
}
export function parseMaximumProperties(value: unknown): unknown {
return _parseReferenceMaximumProperties(value);
}
function _parseReferenceMaximumProperties(value: unknown): unknown {
return parseAmount(value);
}
export function parseSchemasAdditionalProperties(value: unknown): unknown {
return _parseReferenceSchemasAdditionalProperties(value);
}
function _parseReferenceSchemasAdditionalProperties(value: unknown): unknown {
return parseNode(value);
}
export function parseExamplesItems(value: unknown): unknown {
return _parseAnyExamplesItems(value);
}
function _parseAnyExamplesItems(value: unknown): unknown {
return value;
}
export function parseOneOfItems(value: unknown): unknown {
return _parseReferenceOneOfItems(value);
}
function _parseReferenceOneOfItems(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseAnyOfItems(value: unknown): unknown {
return _parseReferenceAnyOfItems(value);
}
function _parseReferenceAnyOfItems(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseAllOfItems(value: unknown): unknown {
return _parseReferenceAllOfItems(value);
}
function _parseReferenceAllOfItems(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseDependentSchemasAdditionalProperties(value: unknown): unknown {
return _parseReferenceDependentSchemasAdditionalProperties(value);
}
function _parseReferenceDependentSchemasAdditionalProperties(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseObjectPropertiesAdditionalProperties(value: unknown): unknown {
return _parseReferenceObjectPropertiesAdditionalProperties(value);
}
function _parseReferenceObjectPropertiesAdditionalProperties(value: unknown): unknown {
return parseNodeReference(value);
}
export function parsePatternPropertiesAdditionalProperties(value: unknown): unknown {
return _parseReferencePatternPropertiesAdditionalProperties(value);
}
function _parseReferencePatternPropertiesAdditionalProperties(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseTupleItemsItems(value: unknown): unknown {
return _parseReferenceTupleItemsItems(value);
}
function _parseReferenceTupleItemsItems(value: unknown): unknown {
return parseNodeReference(value);
}
export function parseBooleanAssertionOptionsItems(value: unknown): unknown {
return _parseReferenceBooleanAssertionOptionsItems(value);
}
function _parseReferenceBooleanAssertionOptionsItems(value: unknown): unknown {
return parseBooleanValue(value);
}
export function parseIntegerAssertionOptionsItems(value: unknown): unknown {
return _parseReferenceIntegerAssertionOptionsItems(value);
}
function _parseReferenceIntegerAssertionOptionsItems(value: unknown): unknown {
return parseIntegerValue(value);
}
export function parseNumberAssertionOptionsItems(value: unknown): unknown {
return _parseReferenceNumberAssertionOptionsItems(value);
}
function _parseReferenceNumberAssertionOptionsItems(value: unknown): unknown {
return parseNumberValue(value);
}
export function parseStringAssertionOptionsItems(value: unknown): unknown {
return _parseReferenceStringAssertionOptionsItems(value);
}
function _parseReferenceStringAssertionOptionsItems(value: unknown): unknown {
return parseStringValue(value);
}
export function parseRequiredItems(value: unknown): unknown {
return _parseReferenceRequiredItems(value);
}
function _parseReferenceRequiredItems(value: unknown): unknown {
return parseStringValue(value);
}
