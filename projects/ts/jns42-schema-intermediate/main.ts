// @generated by
//     __             _____     _                 ___ ___ 
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
//                                 -- www.JsonSchema42.org

/**
JsonSchema42 intermediate schema
*/
export type SchemaJson = ({
    $schema: Schema;
    schemas: Schemas;
});
export type Node = ({
    context?: Context;
    metadata: Metadata;
    types: Types;
    assertions: Assertions;
    applicators: Applicators;
});
/**
some meta information about this schema
*/
export type MetadataSection = ({
    title?: Title;
    description?: Description;
    examples?: Examples;
    deprecated: Deprecated;
});
/**
What types does this schema describe
*/
export type TypesSection = ((TypesSectionItems)[]);
/**
Assertions, per type it is possible that an assertion for a different type is present here, that validator may be used when this schema is used as an applicator
*/
export type AssertionsSection = ({
    boolean?: Boolean;
    integer?: Integer;
    number?: Number;
    string?: String;
    array?: Array;
    map?: Map;
});
/**
Applicators apply other schemas to this one
*/
export type ApplicatorsSection = ({
    reference?: Reference;
    oneOf?: OneOf;
    anyOf?: AnyOf;
    allOf?: AllOf;
    if?: If;
    then?: Then;
    else?: Else;
    not?: Not;
    dependentSchemas?: DependentSchemas;
    objectProperties?: ObjectProperties;
    mapProperties?: MapProperties;
    patternProperties?: PatternProperties;
    propertyNames?: PropertyNames;
    tupleItems?: TupleItems;
    arrayItems?: ArrayItems;
    contains?: Contains;
});
export type BooleanAssertion = ({
    options?: BooleanAssertionOptions;
});
export type IntegerAssertion = ({
    options?: IntegerAssertionOptions;
    minimumInclusive?: IntegerAssertionMinimumInclusive;
    minimumExclusive?: IntegerAssertionMinimumExclusive;
    maximumInclusive?: IntegerAssertionMaximumInclusive;
    maximumExclusive?: IntegerAssertionMaximumExclusive;
    multipleOf?: IntegerAssertionMultipleOf;
});
export type NumberAssertion = ({
    options?: NumberAssertionOptions;
    minimumInclusive?: NumberAssertionMinimumInclusive;
    minimumExclusive?: NumberAssertionMinimumExclusive;
    maximumInclusive?: NumberAssertionMaximumInclusive;
    maximumExclusive?: NumberAssertionMaximumExclusive;
    multipleOf?: NumberAssertionMultipleOf;
});
export type StringAssertion = ({
    options?: StringAssertionOptions;
    minimumLength?: MinimumLength;
    maximumLength?: MaximumLength;
    valuePattern?: ValuePattern;
    valueFormat?: ValueFormat;
});
export type ArrayAssertion = ({
    minimumItems?: MinimumItems;
    maximumItems?: MaximumItems;
    uniqueItems?: UniqueItems;
});
export type MapAssertion = ({
    required?: Required;
    minimumProperties?: MinimumProperties;
    maximumProperties?: MaximumProperties;
});
export type NodeReference = (string);
export type IntegerValue = (number);
export type NumberValue = (number);
export type BooleanValue = (boolean);
export type StringValue = (string);
export type NonEmptyStringValue = (string);
export type Amount = (number);
export type Schema = (("https://schema.JsonSchema42.org/jns42-intermediate/schema.json"));
export type Schemas = ({
    [key: string]: SchemasAdditionalProperties;
});
export type Context = (NodeReference);
export type Metadata = (MetadataSection);
export type Types = (TypesSection);
export type Assertions = (AssertionsSection);
export type Applicators = (ApplicatorsSection);
export type Title = (NonEmptyStringValue);
export type Description = (NonEmptyStringValue);
export type Examples = ((ExamplesItems)[]);
export type Deprecated = (BooleanValue);
export type TypesSectionItems = (("never" | "any" | "null" | "boolean" | "integer" | "number" | "string" | "array" | "map"));
export type Boolean = (BooleanAssertion);
export type Integer = (IntegerAssertion);
export type Number = (NumberAssertion);
export type String = (StringAssertion);
export type Array = (ArrayAssertion);
export type Map = (MapAssertion);
export type Reference = (NodeReference);
export type OneOf = ((OneOfItems)[]);
export type AnyOf = ((AnyOfItems)[]);
export type AllOf = ((AllOfItems)[]);
export type If = (NodeReference);
export type Then = (NodeReference);
export type Else = (NodeReference);
export type Not = (NodeReference);
export type DependentSchemas = ({
    [key: string]: DependentSchemasAdditionalProperties;
});
export type ObjectProperties = ({
    [key: string]: ObjectPropertiesAdditionalProperties;
});
export type MapProperties = (NodeReference);
export type PatternProperties = ({
    [key: string]: PatternPropertiesAdditionalProperties;
});
export type PropertyNames = (NodeReference);
export type TupleItems = ((TupleItemsItems)[]);
export type ArrayItems = (NodeReference);
export type Contains = (NodeReference);
export type BooleanAssertionOptions = ((BooleanAssertionOptionsItems)[]);
export type IntegerAssertionOptions = ((IntegerAssertionOptionsItems)[]);
export type IntegerAssertionMinimumInclusive = (IntegerValue);
export type IntegerAssertionMinimumExclusive = (IntegerValue);
export type IntegerAssertionMaximumInclusive = (IntegerValue);
export type IntegerAssertionMaximumExclusive = (IntegerValue);
export type IntegerAssertionMultipleOf = (IntegerValue);
export type NumberAssertionOptions = ((NumberAssertionOptionsItems)[]);
export type NumberAssertionMinimumInclusive = (NumberValue);
export type NumberAssertionMinimumExclusive = (NumberValue);
export type NumberAssertionMaximumInclusive = (NumberValue);
export type NumberAssertionMaximumExclusive = (NumberValue);
export type NumberAssertionMultipleOf = (NumberValue);
export type StringAssertionOptions = ((StringAssertionOptionsItems)[]);
export type MinimumLength = (Amount);
export type MaximumLength = (Amount);
export type ValuePattern = (NonEmptyStringValue);
export type ValueFormat = (NonEmptyStringValue);
export type MinimumItems = (Amount);
export type MaximumItems = (Amount);
export type UniqueItems = (boolean);
export type Required = ((RequiredItems)[]);
export type MinimumProperties = (Amount);
export type MaximumProperties = (Amount);
export type SchemasAdditionalProperties = (Node);
export type ExamplesItems = (any);
export type OneOfItems = (NodeReference);
export type AnyOfItems = (NodeReference);
export type AllOfItems = (NodeReference);
export type DependentSchemasAdditionalProperties = (NodeReference);
export type ObjectPropertiesAdditionalProperties = (NodeReference);
export type PatternPropertiesAdditionalProperties = (NodeReference);
export type TupleItemsItems = (NodeReference);
export type BooleanAssertionOptionsItems = (BooleanValue);
export type IntegerAssertionOptionsItems = (IntegerValue);
export type NumberAssertionOptionsItems = (NumberValue);
export type StringAssertionOptionsItems = (StringValue);
export type RequiredItems = (StringValue);
export function isSchemaJson(value: unknown): value is SchemaJson {
    if (!(_isMapSchemaJson(value))) {
        return false;
    }
    return true;
}
function _isMapSchemaJson(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    if (!("$schema" in value)) {
        return false;
    }
    if (!("schemas" in value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "$schema":
                if (!isSchema(propertyValue)) {
                    return false;
                }
                continue;
            case "schemas":
                if (!isSchemas(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isNode(value: unknown): value is Node {
    if (!(_isMapNode(value))) {
        return false;
    }
    return true;
}
function _isMapNode(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    if (!("metadata" in value)) {
        return false;
    }
    if (!("types" in value)) {
        return false;
    }
    if (!("assertions" in value)) {
        return false;
    }
    if (!("applicators" in value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "context":
                if (!isContext(propertyValue)) {
                    return false;
                }
                continue;
            case "metadata":
                if (!isMetadata(propertyValue)) {
                    return false;
                }
                continue;
            case "types":
                if (!isTypes(propertyValue)) {
                    return false;
                }
                continue;
            case "assertions":
                if (!isAssertions(propertyValue)) {
                    return false;
                }
                continue;
            case "applicators":
                if (!isApplicators(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isMetadataSection(value: unknown): value is MetadataSection {
    if (!(_isMapMetadataSection(value))) {
        return false;
    }
    return true;
}
function _isMapMetadataSection(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    if (!("deprecated" in value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "title":
                if (!isTitle(propertyValue)) {
                    return false;
                }
                continue;
            case "description":
                if (!isDescription(propertyValue)) {
                    return false;
                }
                continue;
            case "examples":
                if (!isExamples(propertyValue)) {
                    return false;
                }
                continue;
            case "deprecated":
                if (!isDeprecated(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isTypesSection(value: unknown): value is TypesSection {
    if (!(_isArrayTypesSection(value))) {
        return false;
    }
    return true;
}
function _isArrayTypesSection(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isTypesSectionItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isAssertionsSection(value: unknown): value is AssertionsSection {
    if (!(_isMapAssertionsSection(value))) {
        return false;
    }
    return true;
}
function _isMapAssertionsSection(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "boolean":
                if (!isBoolean(propertyValue)) {
                    return false;
                }
                continue;
            case "integer":
                if (!isInteger(propertyValue)) {
                    return false;
                }
                continue;
            case "number":
                if (!isNumber(propertyValue)) {
                    return false;
                }
                continue;
            case "string":
                if (!isString(propertyValue)) {
                    return false;
                }
                continue;
            case "array":
                if (!isArray(propertyValue)) {
                    return false;
                }
                continue;
            case "map":
                if (!isMap(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isApplicatorsSection(value: unknown): value is ApplicatorsSection {
    if (!(_isMapApplicatorsSection(value))) {
        return false;
    }
    return true;
}
function _isMapApplicatorsSection(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "reference":
                if (!isReference(propertyValue)) {
                    return false;
                }
                continue;
            case "oneOf":
                if (!isOneOf(propertyValue)) {
                    return false;
                }
                continue;
            case "anyOf":
                if (!isAnyOf(propertyValue)) {
                    return false;
                }
                continue;
            case "allOf":
                if (!isAllOf(propertyValue)) {
                    return false;
                }
                continue;
            case "if":
                if (!isIf(propertyValue)) {
                    return false;
                }
                continue;
            case "then":
                if (!isThen(propertyValue)) {
                    return false;
                }
                continue;
            case "else":
                if (!isElse(propertyValue)) {
                    return false;
                }
                continue;
            case "not":
                if (!isNot(propertyValue)) {
                    return false;
                }
                continue;
            case "dependentSchemas":
                if (!isDependentSchemas(propertyValue)) {
                    return false;
                }
                continue;
            case "objectProperties":
                if (!isObjectProperties(propertyValue)) {
                    return false;
                }
                continue;
            case "mapProperties":
                if (!isMapProperties(propertyValue)) {
                    return false;
                }
                continue;
            case "patternProperties":
                if (!isPatternProperties(propertyValue)) {
                    return false;
                }
                continue;
            case "propertyNames":
                if (!isPropertyNames(propertyValue)) {
                    return false;
                }
                continue;
            case "tupleItems":
                if (!isTupleItems(propertyValue)) {
                    return false;
                }
                continue;
            case "arrayItems":
                if (!isArrayItems(propertyValue)) {
                    return false;
                }
                continue;
            case "contains":
                if (!isContains(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isBooleanAssertion(value: unknown): value is BooleanAssertion {
    if (!(_isMapBooleanAssertion(value))) {
        return false;
    }
    return true;
}
function _isMapBooleanAssertion(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "options":
                if (!isBooleanAssertionOptions(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isIntegerAssertion(value: unknown): value is IntegerAssertion {
    if (!(_isMapIntegerAssertion(value))) {
        return false;
    }
    return true;
}
function _isMapIntegerAssertion(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "options":
                if (!isIntegerAssertionOptions(propertyValue)) {
                    return false;
                }
                continue;
            case "minimumInclusive":
                if (!isIntegerAssertionMinimumInclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "minimumExclusive":
                if (!isIntegerAssertionMinimumExclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "maximumInclusive":
                if (!isIntegerAssertionMaximumInclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "maximumExclusive":
                if (!isIntegerAssertionMaximumExclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "multipleOf":
                if (!isIntegerAssertionMultipleOf(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isNumberAssertion(value: unknown): value is NumberAssertion {
    if (!(_isMapNumberAssertion(value))) {
        return false;
    }
    return true;
}
function _isMapNumberAssertion(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "options":
                if (!isNumberAssertionOptions(propertyValue)) {
                    return false;
                }
                continue;
            case "minimumInclusive":
                if (!isNumberAssertionMinimumInclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "minimumExclusive":
                if (!isNumberAssertionMinimumExclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "maximumInclusive":
                if (!isNumberAssertionMaximumInclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "maximumExclusive":
                if (!isNumberAssertionMaximumExclusive(propertyValue)) {
                    return false;
                }
                continue;
            case "multipleOf":
                if (!isNumberAssertionMultipleOf(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isStringAssertion(value: unknown): value is StringAssertion {
    if (!(_isMapStringAssertion(value))) {
        return false;
    }
    return true;
}
function _isMapStringAssertion(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "options":
                if (!isStringAssertionOptions(propertyValue)) {
                    return false;
                }
                continue;
            case "minimumLength":
                if (!isMinimumLength(propertyValue)) {
                    return false;
                }
                continue;
            case "maximumLength":
                if (!isMaximumLength(propertyValue)) {
                    return false;
                }
                continue;
            case "valuePattern":
                if (!isValuePattern(propertyValue)) {
                    return false;
                }
                continue;
            case "valueFormat":
                if (!isValueFormat(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isArrayAssertion(value: unknown): value is ArrayAssertion {
    if (!(_isMapArrayAssertion(value))) {
        return false;
    }
    return true;
}
function _isMapArrayAssertion(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "minimumItems":
                if (!isMinimumItems(propertyValue)) {
                    return false;
                }
                continue;
            case "maximumItems":
                if (!isMaximumItems(propertyValue)) {
                    return false;
                }
                continue;
            case "uniqueItems":
                if (!isUniqueItems(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isMapAssertion(value: unknown): value is MapAssertion {
    if (!(_isMapMapAssertion(value))) {
        return false;
    }
    return true;
}
function _isMapMapAssertion(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        switch (propertyName) {
            case "required":
                if (!isRequired(propertyValue)) {
                    return false;
                }
                continue;
            case "minimumProperties":
                if (!isMinimumProperties(propertyValue)) {
                    return false;
                }
                continue;
            case "maximumProperties":
                if (!isMaximumProperties(propertyValue)) {
                    return false;
                }
                continue;
        }
    }
    return true;
}
export function isNodeReference(value: unknown): value is NodeReference {
    if (!(_isStringNodeReference(value))) {
        return false;
    }
    return true;
}
function _isStringNodeReference(value: unknown): value is unknown {
    if (typeof value !== "string") {
        return false;
    }
    return true;
}
export function isIntegerValue(value: unknown): value is IntegerValue {
    if (!(_isIntegerIntegerValue(value))) {
        return false;
    }
    return true;
}
function _isIntegerIntegerValue(value: unknown): value is unknown {
    if (typeof value !== "number" || isNaN(value)) {
        return false;
    }
    if (value % 1 !== 0) {
        return false;
    }
    return true;
}
export function isNumberValue(value: unknown): value is NumberValue {
    if (!(_isNumberNumberValue(value))) {
        return false;
    }
    return true;
}
function _isNumberNumberValue(value: unknown): value is unknown {
    if (typeof value !== "number" || isNaN(value)) {
        return false;
    }
    return true;
}
export function isBooleanValue(value: unknown): value is BooleanValue {
    if (!(_isBooleanBooleanValue(value))) {
        return false;
    }
    return true;
}
function _isBooleanBooleanValue(value: unknown): value is unknown {
    if (typeof value !== "boolean") {
        return false;
    }
    return true;
}
export function isStringValue(value: unknown): value is StringValue {
    if (!(_isStringStringValue(value))) {
        return false;
    }
    return true;
}
function _isStringStringValue(value: unknown): value is unknown {
    if (typeof value !== "string") {
        return false;
    }
    return true;
}
export function isNonEmptyStringValue(value: unknown): value is NonEmptyStringValue {
    if (!(_isStringNonEmptyStringValue(value))) {
        return false;
    }
    return true;
}
function _isStringNonEmptyStringValue(value: unknown): value is unknown {
    if (typeof value !== "string") {
        return false;
    }
    return true;
}
export function isAmount(value: unknown): value is Amount {
    if (!(_isIntegerAmount(value))) {
        return false;
    }
    return true;
}
function _isIntegerAmount(value: unknown): value is unknown {
    if (typeof value !== "number" || isNaN(value)) {
        return false;
    }
    if (value % 1 !== 0) {
        return false;
    }
    return true;
}
export function isSchema(value: unknown): value is Schema {
    if (!(_isStringSchema(value))) {
        return false;
    }
    return true;
}
function _isStringSchema(value: unknown): value is unknown {
    if (typeof value !== "string") {
        return false;
    }
    if (value !== "https://schema.JsonSchema42.org/jns42-intermediate/schema.json") {
        return false;
    }
    return true;
}
export function isSchemas(value: unknown): value is Schemas {
    if (!(_isMapSchemas(value))) {
        return false;
    }
    return true;
}
function _isMapSchemas(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        if (!isSchemasAdditionalProperties(propertyValue)) {
            return false;
        }
    }
    return true;
}
export function isContext(value: unknown): value is Context {
    if (!_isReferenceContext(value)) {
        return false;
    }
    return true;
}
function _isReferenceContext(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isMetadata(value: unknown): value is Metadata {
    if (!_isReferenceMetadata(value)) {
        return false;
    }
    return true;
}
function _isReferenceMetadata(value: unknown): value is unknown {
    if (!isMetadataSection(value)) {
        return false;
    }
    return true;
}
export function isTypes(value: unknown): value is Types {
    if (!_isReferenceTypes(value)) {
        return false;
    }
    return true;
}
function _isReferenceTypes(value: unknown): value is unknown {
    if (!isTypesSection(value)) {
        return false;
    }
    return true;
}
export function isAssertions(value: unknown): value is Assertions {
    if (!_isReferenceAssertions(value)) {
        return false;
    }
    return true;
}
function _isReferenceAssertions(value: unknown): value is unknown {
    if (!isAssertionsSection(value)) {
        return false;
    }
    return true;
}
export function isApplicators(value: unknown): value is Applicators {
    if (!_isReferenceApplicators(value)) {
        return false;
    }
    return true;
}
function _isReferenceApplicators(value: unknown): value is unknown {
    if (!isApplicatorsSection(value)) {
        return false;
    }
    return true;
}
export function isTitle(value: unknown): value is Title {
    if (!_isReferenceTitle(value)) {
        return false;
    }
    return true;
}
function _isReferenceTitle(value: unknown): value is unknown {
    if (!isNonEmptyStringValue(value)) {
        return false;
    }
    return true;
}
export function isDescription(value: unknown): value is Description {
    if (!_isReferenceDescription(value)) {
        return false;
    }
    return true;
}
function _isReferenceDescription(value: unknown): value is unknown {
    if (!isNonEmptyStringValue(value)) {
        return false;
    }
    return true;
}
export function isExamples(value: unknown): value is Examples {
    if (!(_isArrayExamples(value))) {
        return false;
    }
    return true;
}
function _isArrayExamples(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isExamplesItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isDeprecated(value: unknown): value is Deprecated {
    if (!_isReferenceDeprecated(value)) {
        return false;
    }
    return true;
}
function _isReferenceDeprecated(value: unknown): value is unknown {
    if (!isBooleanValue(value)) {
        return false;
    }
    return true;
}
export function isTypesSectionItems(value: unknown): value is TypesSectionItems {
    if (!(_isStringTypesSectionItems(value))) {
        return false;
    }
    return true;
}
function _isStringTypesSectionItems(value: unknown): value is unknown {
    if (typeof value !== "string") {
        return false;
    }
    if (value !== "never" && value !== "any" && value !== "null" && value !== "boolean" && value !== "integer" && value !== "number" && value !== "string" && value !== "array" && value !== "map") {
        return false;
    }
    return true;
}
export function isBoolean(value: unknown): value is Boolean {
    if (!_isReferenceBoolean(value)) {
        return false;
    }
    return true;
}
function _isReferenceBoolean(value: unknown): value is unknown {
    if (!isBooleanAssertion(value)) {
        return false;
    }
    return true;
}
export function isInteger(value: unknown): value is Integer {
    if (!_isReferenceInteger(value)) {
        return false;
    }
    return true;
}
function _isReferenceInteger(value: unknown): value is unknown {
    if (!isIntegerAssertion(value)) {
        return false;
    }
    return true;
}
export function isNumber(value: unknown): value is Number {
    if (!_isReferenceNumber(value)) {
        return false;
    }
    return true;
}
function _isReferenceNumber(value: unknown): value is unknown {
    if (!isNumberAssertion(value)) {
        return false;
    }
    return true;
}
export function isString(value: unknown): value is String {
    if (!_isReferenceString(value)) {
        return false;
    }
    return true;
}
function _isReferenceString(value: unknown): value is unknown {
    if (!isStringAssertion(value)) {
        return false;
    }
    return true;
}
export function isArray(value: unknown): value is Array {
    if (!_isReferenceArray(value)) {
        return false;
    }
    return true;
}
function _isReferenceArray(value: unknown): value is unknown {
    if (!isArrayAssertion(value)) {
        return false;
    }
    return true;
}
export function isMap(value: unknown): value is Map {
    if (!_isReferenceMap(value)) {
        return false;
    }
    return true;
}
function _isReferenceMap(value: unknown): value is unknown {
    if (!isMapAssertion(value)) {
        return false;
    }
    return true;
}
export function isReference(value: unknown): value is Reference {
    if (!_isReferenceReference(value)) {
        return false;
    }
    return true;
}
function _isReferenceReference(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isOneOf(value: unknown): value is OneOf {
    if (!(_isArrayOneOf(value))) {
        return false;
    }
    return true;
}
function _isArrayOneOf(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isOneOfItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isAnyOf(value: unknown): value is AnyOf {
    if (!(_isArrayAnyOf(value))) {
        return false;
    }
    return true;
}
function _isArrayAnyOf(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isAnyOfItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isAllOf(value: unknown): value is AllOf {
    if (!(_isArrayAllOf(value))) {
        return false;
    }
    return true;
}
function _isArrayAllOf(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isAllOfItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isIf(value: unknown): value is If {
    if (!_isReferenceIf(value)) {
        return false;
    }
    return true;
}
function _isReferenceIf(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isThen(value: unknown): value is Then {
    if (!_isReferenceThen(value)) {
        return false;
    }
    return true;
}
function _isReferenceThen(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isElse(value: unknown): value is Else {
    if (!_isReferenceElse(value)) {
        return false;
    }
    return true;
}
function _isReferenceElse(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isNot(value: unknown): value is Not {
    if (!_isReferenceNot(value)) {
        return false;
    }
    return true;
}
function _isReferenceNot(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isDependentSchemas(value: unknown): value is DependentSchemas {
    if (!(_isMapDependentSchemas(value))) {
        return false;
    }
    return true;
}
function _isMapDependentSchemas(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        if (!isDependentSchemasAdditionalProperties(propertyValue)) {
            return false;
        }
    }
    return true;
}
export function isObjectProperties(value: unknown): value is ObjectProperties {
    if (!(_isMapObjectProperties(value))) {
        return false;
    }
    return true;
}
function _isMapObjectProperties(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        if (!isObjectPropertiesAdditionalProperties(propertyValue)) {
            return false;
        }
    }
    return true;
}
export function isMapProperties(value: unknown): value is MapProperties {
    if (!_isReferenceMapProperties(value)) {
        return false;
    }
    return true;
}
function _isReferenceMapProperties(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isPatternProperties(value: unknown): value is PatternProperties {
    if (!(_isMapPatternProperties(value))) {
        return false;
    }
    return true;
}
function _isMapPatternProperties(value: unknown): value is unknown {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        return false;
    }
    for (const propertyName in value) {
        const propertyValue = value[propertyName as keyof typeof value];
        if (!isPatternPropertiesAdditionalProperties(propertyValue)) {
            return false;
        }
    }
    return true;
}
export function isPropertyNames(value: unknown): value is PropertyNames {
    if (!_isReferencePropertyNames(value)) {
        return false;
    }
    return true;
}
function _isReferencePropertyNames(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isTupleItems(value: unknown): value is TupleItems {
    if (!(_isArrayTupleItems(value))) {
        return false;
    }
    return true;
}
function _isArrayTupleItems(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isTupleItemsItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isArrayItems(value: unknown): value is ArrayItems {
    if (!_isReferenceArrayItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceArrayItems(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isContains(value: unknown): value is Contains {
    if (!_isReferenceContains(value)) {
        return false;
    }
    return true;
}
function _isReferenceContains(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isBooleanAssertionOptions(value: unknown): value is BooleanAssertionOptions {
    if (!(_isArrayBooleanAssertionOptions(value))) {
        return false;
    }
    return true;
}
function _isArrayBooleanAssertionOptions(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isBooleanAssertionOptionsItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isIntegerAssertionOptions(value: unknown): value is IntegerAssertionOptions {
    if (!(_isArrayIntegerAssertionOptions(value))) {
        return false;
    }
    return true;
}
function _isArrayIntegerAssertionOptions(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isIntegerAssertionOptionsItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isIntegerAssertionMinimumInclusive(value: unknown): value is IntegerAssertionMinimumInclusive {
    if (!_isReferenceIntegerAssertionMinimumInclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceIntegerAssertionMinimumInclusive(value: unknown): value is unknown {
    if (!isIntegerValue(value)) {
        return false;
    }
    return true;
}
export function isIntegerAssertionMinimumExclusive(value: unknown): value is IntegerAssertionMinimumExclusive {
    if (!_isReferenceIntegerAssertionMinimumExclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceIntegerAssertionMinimumExclusive(value: unknown): value is unknown {
    if (!isIntegerValue(value)) {
        return false;
    }
    return true;
}
export function isIntegerAssertionMaximumInclusive(value: unknown): value is IntegerAssertionMaximumInclusive {
    if (!_isReferenceIntegerAssertionMaximumInclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceIntegerAssertionMaximumInclusive(value: unknown): value is unknown {
    if (!isIntegerValue(value)) {
        return false;
    }
    return true;
}
export function isIntegerAssertionMaximumExclusive(value: unknown): value is IntegerAssertionMaximumExclusive {
    if (!_isReferenceIntegerAssertionMaximumExclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceIntegerAssertionMaximumExclusive(value: unknown): value is unknown {
    if (!isIntegerValue(value)) {
        return false;
    }
    return true;
}
export function isIntegerAssertionMultipleOf(value: unknown): value is IntegerAssertionMultipleOf {
    if (!_isReferenceIntegerAssertionMultipleOf(value)) {
        return false;
    }
    return true;
}
function _isReferenceIntegerAssertionMultipleOf(value: unknown): value is unknown {
    if (!isIntegerValue(value)) {
        return false;
    }
    return true;
}
export function isNumberAssertionOptions(value: unknown): value is NumberAssertionOptions {
    if (!(_isArrayNumberAssertionOptions(value))) {
        return false;
    }
    return true;
}
function _isArrayNumberAssertionOptions(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isNumberAssertionOptionsItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isNumberAssertionMinimumInclusive(value: unknown): value is NumberAssertionMinimumInclusive {
    if (!_isReferenceNumberAssertionMinimumInclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceNumberAssertionMinimumInclusive(value: unknown): value is unknown {
    if (!isNumberValue(value)) {
        return false;
    }
    return true;
}
export function isNumberAssertionMinimumExclusive(value: unknown): value is NumberAssertionMinimumExclusive {
    if (!_isReferenceNumberAssertionMinimumExclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceNumberAssertionMinimumExclusive(value: unknown): value is unknown {
    if (!isNumberValue(value)) {
        return false;
    }
    return true;
}
export function isNumberAssertionMaximumInclusive(value: unknown): value is NumberAssertionMaximumInclusive {
    if (!_isReferenceNumberAssertionMaximumInclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceNumberAssertionMaximumInclusive(value: unknown): value is unknown {
    if (!isNumberValue(value)) {
        return false;
    }
    return true;
}
export function isNumberAssertionMaximumExclusive(value: unknown): value is NumberAssertionMaximumExclusive {
    if (!_isReferenceNumberAssertionMaximumExclusive(value)) {
        return false;
    }
    return true;
}
function _isReferenceNumberAssertionMaximumExclusive(value: unknown): value is unknown {
    if (!isNumberValue(value)) {
        return false;
    }
    return true;
}
export function isNumberAssertionMultipleOf(value: unknown): value is NumberAssertionMultipleOf {
    if (!_isReferenceNumberAssertionMultipleOf(value)) {
        return false;
    }
    return true;
}
function _isReferenceNumberAssertionMultipleOf(value: unknown): value is unknown {
    if (!isNumberValue(value)) {
        return false;
    }
    return true;
}
export function isStringAssertionOptions(value: unknown): value is StringAssertionOptions {
    if (!(_isArrayStringAssertionOptions(value))) {
        return false;
    }
    return true;
}
function _isArrayStringAssertionOptions(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (!isStringAssertionOptionsItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isMinimumLength(value: unknown): value is MinimumLength {
    if (!_isReferenceMinimumLength(value)) {
        return false;
    }
    return true;
}
function _isReferenceMinimumLength(value: unknown): value is unknown {
    if (!isAmount(value)) {
        return false;
    }
    return true;
}
export function isMaximumLength(value: unknown): value is MaximumLength {
    if (!_isReferenceMaximumLength(value)) {
        return false;
    }
    return true;
}
function _isReferenceMaximumLength(value: unknown): value is unknown {
    if (!isAmount(value)) {
        return false;
    }
    return true;
}
export function isValuePattern(value: unknown): value is ValuePattern {
    if (!_isReferenceValuePattern(value)) {
        return false;
    }
    return true;
}
function _isReferenceValuePattern(value: unknown): value is unknown {
    if (!isNonEmptyStringValue(value)) {
        return false;
    }
    return true;
}
export function isValueFormat(value: unknown): value is ValueFormat {
    if (!_isReferenceValueFormat(value)) {
        return false;
    }
    return true;
}
function _isReferenceValueFormat(value: unknown): value is unknown {
    if (!isNonEmptyStringValue(value)) {
        return false;
    }
    return true;
}
export function isMinimumItems(value: unknown): value is MinimumItems {
    if (!_isReferenceMinimumItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceMinimumItems(value: unknown): value is unknown {
    if (!isAmount(value)) {
        return false;
    }
    return true;
}
export function isMaximumItems(value: unknown): value is MaximumItems {
    if (!_isReferenceMaximumItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceMaximumItems(value: unknown): value is unknown {
    if (!isAmount(value)) {
        return false;
    }
    return true;
}
export function isUniqueItems(value: unknown): value is UniqueItems {
    if (!(_isBooleanUniqueItems(value))) {
        return false;
    }
    return true;
}
function _isBooleanUniqueItems(value: unknown): value is unknown {
    if (typeof value !== "boolean") {
        return false;
    }
    return true;
}
export function isRequired(value: unknown): value is Required {
    if (!(_isArrayRequired(value))) {
        return false;
    }
    return true;
}
function _isArrayRequired(value: unknown): value is unknown {
    if (!Array.isArray(value)) {
        return false;
    }
    const elementValueSeen = new Set<unknown>();
    for (let elementIndex = 0; elementIndex < value.length; elementIndex++) {
        const elementValue = value[elementIndex];
        if (elementValueSeen.has(elementValue)) {
            return false;
        }
        elementValueSeen.add(elementValue);
        if (!isRequiredItems(elementValue)) {
            return false;
        }
    }
    return true;
}
export function isMinimumProperties(value: unknown): value is MinimumProperties {
    if (!_isReferenceMinimumProperties(value)) {
        return false;
    }
    return true;
}
function _isReferenceMinimumProperties(value: unknown): value is unknown {
    if (!isAmount(value)) {
        return false;
    }
    return true;
}
export function isMaximumProperties(value: unknown): value is MaximumProperties {
    if (!_isReferenceMaximumProperties(value)) {
        return false;
    }
    return true;
}
function _isReferenceMaximumProperties(value: unknown): value is unknown {
    if (!isAmount(value)) {
        return false;
    }
    return true;
}
export function isSchemasAdditionalProperties(value: unknown): value is SchemasAdditionalProperties {
    if (!_isReferenceSchemasAdditionalProperties(value)) {
        return false;
    }
    return true;
}
function _isReferenceSchemasAdditionalProperties(value: unknown): value is unknown {
    if (!isNode(value)) {
        return false;
    }
    return true;
}
export function isExamplesItems(value: unknown): value is ExamplesItems {
    if (!(_isAnyExamplesItems(value))) {
        return false;
    }
    return true;
}
function _isAnyExamplesItems(value: unknown): value is unknown {
    return true;
}
export function isOneOfItems(value: unknown): value is OneOfItems {
    if (!_isReferenceOneOfItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceOneOfItems(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isAnyOfItems(value: unknown): value is AnyOfItems {
    if (!_isReferenceAnyOfItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceAnyOfItems(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isAllOfItems(value: unknown): value is AllOfItems {
    if (!_isReferenceAllOfItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceAllOfItems(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isDependentSchemasAdditionalProperties(value: unknown): value is DependentSchemasAdditionalProperties {
    if (!_isReferenceDependentSchemasAdditionalProperties(value)) {
        return false;
    }
    return true;
}
function _isReferenceDependentSchemasAdditionalProperties(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isObjectPropertiesAdditionalProperties(value: unknown): value is ObjectPropertiesAdditionalProperties {
    if (!_isReferenceObjectPropertiesAdditionalProperties(value)) {
        return false;
    }
    return true;
}
function _isReferenceObjectPropertiesAdditionalProperties(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isPatternPropertiesAdditionalProperties(value: unknown): value is PatternPropertiesAdditionalProperties {
    if (!_isReferencePatternPropertiesAdditionalProperties(value)) {
        return false;
    }
    return true;
}
function _isReferencePatternPropertiesAdditionalProperties(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isTupleItemsItems(value: unknown): value is TupleItemsItems {
    if (!_isReferenceTupleItemsItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceTupleItemsItems(value: unknown): value is unknown {
    if (!isNodeReference(value)) {
        return false;
    }
    return true;
}
export function isBooleanAssertionOptionsItems(value: unknown): value is BooleanAssertionOptionsItems {
    if (!_isReferenceBooleanAssertionOptionsItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceBooleanAssertionOptionsItems(value: unknown): value is unknown {
    if (!isBooleanValue(value)) {
        return false;
    }
    return true;
}
export function isIntegerAssertionOptionsItems(value: unknown): value is IntegerAssertionOptionsItems {
    if (!_isReferenceIntegerAssertionOptionsItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceIntegerAssertionOptionsItems(value: unknown): value is unknown {
    if (!isIntegerValue(value)) {
        return false;
    }
    return true;
}
export function isNumberAssertionOptionsItems(value: unknown): value is NumberAssertionOptionsItems {
    if (!_isReferenceNumberAssertionOptionsItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceNumberAssertionOptionsItems(value: unknown): value is unknown {
    if (!isNumberValue(value)) {
        return false;
    }
    return true;
}
export function isStringAssertionOptionsItems(value: unknown): value is StringAssertionOptionsItems {
    if (!_isReferenceStringAssertionOptionsItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceStringAssertionOptionsItems(value: unknown): value is unknown {
    if (!isStringValue(value)) {
        return false;
    }
    return true;
}
export function isRequiredItems(value: unknown): value is RequiredItems {
    if (!_isReferenceRequiredItems(value)) {
        return false;
    }
    return true;
}
function _isReferenceRequiredItems(value: unknown): value is unknown {
    if (!isStringValue(value)) {
        return false;
    }
    return true;
}
