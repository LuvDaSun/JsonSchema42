// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.8.6                          -- www.JsonSchema42.org
import * as types from "./types.js";
export function isSchemaJson(value: unknown): value is types.SchemaJson {
if(!_isMapSchemaJson(value)) {
return false;
}
return true;
}
function _isMapSchemaJson(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
if(!("$schema" in value)) {
return false;
}
if(!("schemas" in value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "$schema":
if(!isSchema(propertyValue)) {
return false;
}
break;
case "schemas":
if(!isSchemas(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isNode(value: unknown): value is types.Node {
if(!_isMapNode(value)) {
return false;
}
return true;
}
function _isMapNode(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
if(!("metadata" in value)) {
return false;
}
if(!("types" in value)) {
return false;
}
if(!("assertions" in value)) {
return false;
}
if(!("applicators" in value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "context":
if(!isContext(propertyValue)) {
return false;
}
break;
case "metadata":
if(!isMetadata(propertyValue)) {
return false;
}
break;
case "types":
if(!isTypes(propertyValue)) {
return false;
}
break;
case "assertions":
if(!isAssertions(propertyValue)) {
return false;
}
break;
case "applicators":
if(!isApplicators(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isMetadataSection(value: unknown): value is types.MetadataSection {
if(!_isMapMetadataSection(value)) {
return false;
}
return true;
}
function _isMapMetadataSection(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
if(!("deprecated" in value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "title":
if(!isTitle(propertyValue)) {
return false;
}
break;
case "description":
if(!isDescription(propertyValue)) {
return false;
}
break;
case "examples":
if(!isExamples(propertyValue)) {
return false;
}
break;
case "deprecated":
if(!isDeprecated(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isTypesSection(value: unknown): value is types.TypesSection {
if(!_isArrayTypesSection(value)) {
return false;
}
return true;
}
function _isArrayTypesSection(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isTypesSectionItems(elementValue)) {
return false;
}
}
return true;
}
export function isAssertionsSection(value: unknown): value is types.AssertionsSection {
if(!_isMapAssertionsSection(value)) {
return false;
}
return true;
}
function _isMapAssertionsSection(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "boolean":
if(!isBoolean(propertyValue)) {
return false;
}
break;
case "integer":
if(!isInteger(propertyValue)) {
return false;
}
break;
case "number":
if(!isNumber(propertyValue)) {
return false;
}
break;
case "string":
if(!isString(propertyValue)) {
return false;
}
break;
case "array":
if(!isArray(propertyValue)) {
return false;
}
break;
case "map":
if(!isMap(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isApplicatorsSection(value: unknown): value is types.ApplicatorsSection {
if(!_isMapApplicatorsSection(value)) {
return false;
}
return true;
}
function _isMapApplicatorsSection(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "reference":
if(!isReference(propertyValue)) {
return false;
}
break;
case "oneOf":
if(!isOneOf(propertyValue)) {
return false;
}
break;
case "anyOf":
if(!isAnyOf(propertyValue)) {
return false;
}
break;
case "allOf":
if(!isAllOf(propertyValue)) {
return false;
}
break;
case "if":
if(!isIf(propertyValue)) {
return false;
}
break;
case "then":
if(!isThen(propertyValue)) {
return false;
}
break;
case "else":
if(!isElse(propertyValue)) {
return false;
}
break;
case "not":
if(!isNot(propertyValue)) {
return false;
}
break;
case "dependentSchemas":
if(!isDependentSchemas(propertyValue)) {
return false;
}
break;
case "objectProperties":
if(!isObjectProperties(propertyValue)) {
return false;
}
break;
case "mapProperties":
if(!isMapProperties(propertyValue)) {
return false;
}
break;
case "patternProperties":
if(!isPatternProperties(propertyValue)) {
return false;
}
break;
case "propertyNames":
if(!isPropertyNames(propertyValue)) {
return false;
}
break;
case "tupleItems":
if(!isTupleItems(propertyValue)) {
return false;
}
break;
case "arrayItems":
if(!isArrayItems(propertyValue)) {
return false;
}
break;
case "contains":
if(!isContains(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isBooleanAssertion(value: unknown): value is types.BooleanAssertion {
if(!_isMapBooleanAssertion(value)) {
return false;
}
return true;
}
function _isMapBooleanAssertion(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "options":
if(!isBooleanAssertionOptions(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isIntegerAssertion(value: unknown): value is types.IntegerAssertion {
if(!_isMapIntegerAssertion(value)) {
return false;
}
return true;
}
function _isMapIntegerAssertion(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "options":
if(!isIntegerAssertionOptions(propertyValue)) {
return false;
}
break;
case "minimumInclusive":
if(!isIntegerAssertionMinimumInclusive(propertyValue)) {
return false;
}
break;
case "minimumExclusive":
if(!isIntegerAssertionMinimumExclusive(propertyValue)) {
return false;
}
break;
case "maximumInclusive":
if(!isIntegerAssertionMaximumInclusive(propertyValue)) {
return false;
}
break;
case "maximumExclusive":
if(!isIntegerAssertionMaximumExclusive(propertyValue)) {
return false;
}
break;
case "multipleOf":
if(!isIntegerAssertionMultipleOf(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isNumberAssertion(value: unknown): value is types.NumberAssertion {
if(!_isMapNumberAssertion(value)) {
return false;
}
return true;
}
function _isMapNumberAssertion(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "options":
if(!isNumberAssertionOptions(propertyValue)) {
return false;
}
break;
case "minimumInclusive":
if(!isNumberAssertionMinimumInclusive(propertyValue)) {
return false;
}
break;
case "minimumExclusive":
if(!isNumberAssertionMinimumExclusive(propertyValue)) {
return false;
}
break;
case "maximumInclusive":
if(!isNumberAssertionMaximumInclusive(propertyValue)) {
return false;
}
break;
case "maximumExclusive":
if(!isNumberAssertionMaximumExclusive(propertyValue)) {
return false;
}
break;
case "multipleOf":
if(!isNumberAssertionMultipleOf(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isStringAssertion(value: unknown): value is types.StringAssertion {
if(!_isMapStringAssertion(value)) {
return false;
}
return true;
}
function _isMapStringAssertion(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "options":
if(!isStringAssertionOptions(propertyValue)) {
return false;
}
break;
case "minimumLength":
if(!isMinimumLength(propertyValue)) {
return false;
}
break;
case "maximumLength":
if(!isMaximumLength(propertyValue)) {
return false;
}
break;
case "valuePattern":
if(!isValuePattern(propertyValue)) {
return false;
}
break;
case "valueFormat":
if(!isValueFormat(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isArrayAssertion(value: unknown): value is types.ArrayAssertion {
if(!_isMapArrayAssertion(value)) {
return false;
}
return true;
}
function _isMapArrayAssertion(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "minimumItems":
if(!isMinimumItems(propertyValue)) {
return false;
}
break;
case "maximumItems":
if(!isMaximumItems(propertyValue)) {
return false;
}
break;
case "uniqueItems":
if(!isUniqueItems(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isMapAssertion(value: unknown): value is types.MapAssertion {
if(!_isMapMapAssertion(value)) {
return false;
}
return true;
}
function _isMapMapAssertion(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
switch(propertyName) {
case "required":
if(!isRequired(propertyValue)) {
return false;
}
break;
case "minimumProperties":
if(!isMinimumProperties(propertyValue)) {
return false;
}
break;
case "maximumProperties":
if(!isMaximumProperties(propertyValue)) {
return false;
}
break;
}
}
return true;
}
export function isNodeReference(value: unknown): value is types.NodeReference {
if(!_isStringNodeReference(value)) {
return false;
}
return true;
}
function _isStringNodeReference(value: unknown): value is unknown {
if(typeof value !== "string") {
return false;
}
return true;
}
export function isIntegerValue(value: unknown): value is types.IntegerValue {
if(!_isIntegerIntegerValue(value)) {
return false;
}
return true;
}
function _isIntegerIntegerValue(value: unknown): value is unknown {
if(typeof value !== "number" || isNaN(value)) {
return false;
}
return true;
}
export function isNumberValue(value: unknown): value is types.NumberValue {
if(!_isNumberNumberValue(value)) {
return false;
}
return true;
}
function _isNumberNumberValue(value: unknown): value is unknown {
if(typeof value !== "number" || isNaN(value) || value % 1 !== 0) {
return false;
}
return true;
}
export function isBooleanValue(value: unknown): value is types.BooleanValue {
if(!_isBooleanBooleanValue(value)) {
return false;
}
return true;
}
function _isBooleanBooleanValue(value: unknown): value is unknown {
if(typeof value !== "boolean") {
return false;
}
return true;
}
export function isStringValue(value: unknown): value is types.StringValue {
if(!_isStringStringValue(value)) {
return false;
}
return true;
}
function _isStringStringValue(value: unknown): value is unknown {
if(typeof value !== "string") {
return false;
}
return true;
}
export function isNonEmptyStringValue(value: unknown): value is types.NonEmptyStringValue {
if(!_isStringNonEmptyStringValue(value)) {
return false;
}
return true;
}
function _isStringNonEmptyStringValue(value: unknown): value is unknown {
if(typeof value !== "string") {
return false;
}
return true;
}
export function isAmount(value: unknown): value is types.Amount {
if(!_isIntegerAmount(value)) {
return false;
}
return true;
}
function _isIntegerAmount(value: unknown): value is unknown {
if(typeof value !== "number" || isNaN(value)) {
return false;
}
return true;
}
export function isSchema(value: unknown): value is types.Schema {
if(!_isStringSchema(value)) {
return false;
}
return true;
}
function _isStringSchema(value: unknown): value is unknown {
if(typeof value !== "string") {
return false;
}
if(value !== "https://schema.JsonSchema42.org/jns42-intermediate/schema.json") {
return false;
}
return true;
}
export function isSchemas(value: unknown): value is types.Schemas {
if(!_isMapSchemas(value)) {
return false;
}
return true;
}
function _isMapSchemas(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
if(!isSchemasAdditionalProperties(propertyValue)) {
return false;
}
}
return true;
}
export function isContext(value: unknown): value is types.Context {
if(!_isReferenceContext(value)) {
return false;
}
return true;
}
function _isReferenceContext(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isMetadata(value: unknown): value is types.Metadata {
if(!_isReferenceMetadata(value)) {
return false;
}
return true;
}
function _isReferenceMetadata(value: unknown): value is unknown {
if(!isMetadataSection(value)) {
return false;
}
return true;
}
export function isTypes(value: unknown): value is types.Types {
if(!_isReferenceTypes(value)) {
return false;
}
return true;
}
function _isReferenceTypes(value: unknown): value is unknown {
if(!isTypesSection(value)) {
return false;
}
return true;
}
export function isAssertions(value: unknown): value is types.Assertions {
if(!_isReferenceAssertions(value)) {
return false;
}
return true;
}
function _isReferenceAssertions(value: unknown): value is unknown {
if(!isAssertionsSection(value)) {
return false;
}
return true;
}
export function isApplicators(value: unknown): value is types.Applicators {
if(!_isReferenceApplicators(value)) {
return false;
}
return true;
}
function _isReferenceApplicators(value: unknown): value is unknown {
if(!isApplicatorsSection(value)) {
return false;
}
return true;
}
export function isTitle(value: unknown): value is types.Title {
if(!_isReferenceTitle(value)) {
return false;
}
return true;
}
function _isReferenceTitle(value: unknown): value is unknown {
if(!isNonEmptyStringValue(value)) {
return false;
}
return true;
}
export function isDescription(value: unknown): value is types.Description {
if(!_isReferenceDescription(value)) {
return false;
}
return true;
}
function _isReferenceDescription(value: unknown): value is unknown {
if(!isNonEmptyStringValue(value)) {
return false;
}
return true;
}
export function isExamples(value: unknown): value is types.Examples {
if(!_isArrayExamples(value)) {
return false;
}
return true;
}
function _isArrayExamples(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isExamplesItems(elementValue)) {
return false;
}
}
return true;
}
export function isDeprecated(value: unknown): value is types.Deprecated {
if(!_isReferenceDeprecated(value)) {
return false;
}
return true;
}
function _isReferenceDeprecated(value: unknown): value is unknown {
if(!isBooleanValue(value)) {
return false;
}
return true;
}
export function isTypesSectionItems(value: unknown): value is types.TypesSectionItems {
if(!_isStringTypesSectionItems(value)) {
return false;
}
return true;
}
function _isStringTypesSectionItems(value: unknown): value is unknown {
if(typeof value !== "string") {
return false;
}
if(value !== "never" && value !== "any" && value !== "null" && value !== "boolean" && value !== "integer" && value !== "number" && value !== "string" && value !== "array" && value !== "map") {
return false;
}
return true;
}
export function isBoolean(value: unknown): value is types.Boolean {
if(!_isReferenceBoolean(value)) {
return false;
}
return true;
}
function _isReferenceBoolean(value: unknown): value is unknown {
if(!isBooleanAssertion(value)) {
return false;
}
return true;
}
export function isInteger(value: unknown): value is types.Integer {
if(!_isReferenceInteger(value)) {
return false;
}
return true;
}
function _isReferenceInteger(value: unknown): value is unknown {
if(!isIntegerAssertion(value)) {
return false;
}
return true;
}
export function isNumber(value: unknown): value is types.Number {
if(!_isReferenceNumber(value)) {
return false;
}
return true;
}
function _isReferenceNumber(value: unknown): value is unknown {
if(!isNumberAssertion(value)) {
return false;
}
return true;
}
export function isString(value: unknown): value is types.String {
if(!_isReferenceString(value)) {
return false;
}
return true;
}
function _isReferenceString(value: unknown): value is unknown {
if(!isStringAssertion(value)) {
return false;
}
return true;
}
export function isArray(value: unknown): value is types.Array {
if(!_isReferenceArray(value)) {
return false;
}
return true;
}
function _isReferenceArray(value: unknown): value is unknown {
if(!isArrayAssertion(value)) {
return false;
}
return true;
}
export function isMap(value: unknown): value is types.Map {
if(!_isReferenceMap(value)) {
return false;
}
return true;
}
function _isReferenceMap(value: unknown): value is unknown {
if(!isMapAssertion(value)) {
return false;
}
return true;
}
export function isReference(value: unknown): value is types.Reference {
if(!_isReferenceReference(value)) {
return false;
}
return true;
}
function _isReferenceReference(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isOneOf(value: unknown): value is types.OneOf {
if(!_isArrayOneOf(value)) {
return false;
}
return true;
}
function _isArrayOneOf(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isOneOfItems(elementValue)) {
return false;
}
}
return true;
}
export function isAnyOf(value: unknown): value is types.AnyOf {
if(!_isArrayAnyOf(value)) {
return false;
}
return true;
}
function _isArrayAnyOf(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isAnyOfItems(elementValue)) {
return false;
}
}
return true;
}
export function isAllOf(value: unknown): value is types.AllOf {
if(!_isArrayAllOf(value)) {
return false;
}
return true;
}
function _isArrayAllOf(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isAllOfItems(elementValue)) {
return false;
}
}
return true;
}
export function isIf(value: unknown): value is types.If {
if(!_isReferenceIf(value)) {
return false;
}
return true;
}
function _isReferenceIf(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isThen(value: unknown): value is types.Then {
if(!_isReferenceThen(value)) {
return false;
}
return true;
}
function _isReferenceThen(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isElse(value: unknown): value is types.Else {
if(!_isReferenceElse(value)) {
return false;
}
return true;
}
function _isReferenceElse(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isNot(value: unknown): value is types.Not {
if(!_isReferenceNot(value)) {
return false;
}
return true;
}
function _isReferenceNot(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isDependentSchemas(value: unknown): value is types.DependentSchemas {
if(!_isMapDependentSchemas(value)) {
return false;
}
return true;
}
function _isMapDependentSchemas(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
if(!isDependentSchemasAdditionalProperties(propertyValue)) {
return false;
}
}
return true;
}
export function isObjectProperties(value: unknown): value is types.ObjectProperties {
if(!_isMapObjectProperties(value)) {
return false;
}
return true;
}
function _isMapObjectProperties(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
if(!isObjectPropertiesAdditionalProperties(propertyValue)) {
return false;
}
}
return true;
}
export function isMapProperties(value: unknown): value is types.MapProperties {
if(!_isReferenceMapProperties(value)) {
return false;
}
return true;
}
function _isReferenceMapProperties(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isPatternProperties(value: unknown): value is types.PatternProperties {
if(!_isMapPatternProperties(value)) {
return false;
}
return true;
}
function _isMapPatternProperties(value: unknown): value is unknown {
if(typeof value !== "object" || value === null || Array.isArray(value)) {
return false;
}
for(const propertyName in value) {
const propertyValue = value[propertyName as keyof typeof value];
if(!isPatternPropertiesAdditionalProperties(propertyValue)) {
return false;
}
}
return true;
}
export function isPropertyNames(value: unknown): value is types.PropertyNames {
if(!_isReferencePropertyNames(value)) {
return false;
}
return true;
}
function _isReferencePropertyNames(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isTupleItems(value: unknown): value is types.TupleItems {
if(!_isArrayTupleItems(value)) {
return false;
}
return true;
}
function _isArrayTupleItems(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isTupleItemsItems(elementValue)) {
return false;
}
}
return true;
}
export function isArrayItems(value: unknown): value is types.ArrayItems {
if(!_isReferenceArrayItems(value)) {
return false;
}
return true;
}
function _isReferenceArrayItems(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isContains(value: unknown): value is types.Contains {
if(!_isReferenceContains(value)) {
return false;
}
return true;
}
function _isReferenceContains(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isBooleanAssertionOptions(value: unknown): value is types.BooleanAssertionOptions {
if(!_isArrayBooleanAssertionOptions(value)) {
return false;
}
return true;
}
function _isArrayBooleanAssertionOptions(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isBooleanAssertionOptionsItems(elementValue)) {
return false;
}
}
return true;
}
export function isIntegerAssertionOptions(value: unknown): value is types.IntegerAssertionOptions {
if(!_isArrayIntegerAssertionOptions(value)) {
return false;
}
return true;
}
function _isArrayIntegerAssertionOptions(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isIntegerAssertionOptionsItems(elementValue)) {
return false;
}
}
return true;
}
export function isIntegerAssertionMinimumInclusive(value: unknown): value is types.IntegerAssertionMinimumInclusive {
if(!_isReferenceIntegerAssertionMinimumInclusive(value)) {
return false;
}
return true;
}
function _isReferenceIntegerAssertionMinimumInclusive(value: unknown): value is unknown {
if(!isIntegerValue(value)) {
return false;
}
return true;
}
export function isIntegerAssertionMinimumExclusive(value: unknown): value is types.IntegerAssertionMinimumExclusive {
if(!_isReferenceIntegerAssertionMinimumExclusive(value)) {
return false;
}
return true;
}
function _isReferenceIntegerAssertionMinimumExclusive(value: unknown): value is unknown {
if(!isIntegerValue(value)) {
return false;
}
return true;
}
export function isIntegerAssertionMaximumInclusive(value: unknown): value is types.IntegerAssertionMaximumInclusive {
if(!_isReferenceIntegerAssertionMaximumInclusive(value)) {
return false;
}
return true;
}
function _isReferenceIntegerAssertionMaximumInclusive(value: unknown): value is unknown {
if(!isIntegerValue(value)) {
return false;
}
return true;
}
export function isIntegerAssertionMaximumExclusive(value: unknown): value is types.IntegerAssertionMaximumExclusive {
if(!_isReferenceIntegerAssertionMaximumExclusive(value)) {
return false;
}
return true;
}
function _isReferenceIntegerAssertionMaximumExclusive(value: unknown): value is unknown {
if(!isIntegerValue(value)) {
return false;
}
return true;
}
export function isIntegerAssertionMultipleOf(value: unknown): value is types.IntegerAssertionMultipleOf {
if(!_isReferenceIntegerAssertionMultipleOf(value)) {
return false;
}
return true;
}
function _isReferenceIntegerAssertionMultipleOf(value: unknown): value is unknown {
if(!isIntegerValue(value)) {
return false;
}
return true;
}
export function isNumberAssertionOptions(value: unknown): value is types.NumberAssertionOptions {
if(!_isArrayNumberAssertionOptions(value)) {
return false;
}
return true;
}
function _isArrayNumberAssertionOptions(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isNumberAssertionOptionsItems(elementValue)) {
return false;
}
}
return true;
}
export function isNumberAssertionMinimumInclusive(value: unknown): value is types.NumberAssertionMinimumInclusive {
if(!_isReferenceNumberAssertionMinimumInclusive(value)) {
return false;
}
return true;
}
function _isReferenceNumberAssertionMinimumInclusive(value: unknown): value is unknown {
if(!isNumberValue(value)) {
return false;
}
return true;
}
export function isNumberAssertionMinimumExclusive(value: unknown): value is types.NumberAssertionMinimumExclusive {
if(!_isReferenceNumberAssertionMinimumExclusive(value)) {
return false;
}
return true;
}
function _isReferenceNumberAssertionMinimumExclusive(value: unknown): value is unknown {
if(!isNumberValue(value)) {
return false;
}
return true;
}
export function isNumberAssertionMaximumInclusive(value: unknown): value is types.NumberAssertionMaximumInclusive {
if(!_isReferenceNumberAssertionMaximumInclusive(value)) {
return false;
}
return true;
}
function _isReferenceNumberAssertionMaximumInclusive(value: unknown): value is unknown {
if(!isNumberValue(value)) {
return false;
}
return true;
}
export function isNumberAssertionMaximumExclusive(value: unknown): value is types.NumberAssertionMaximumExclusive {
if(!_isReferenceNumberAssertionMaximumExclusive(value)) {
return false;
}
return true;
}
function _isReferenceNumberAssertionMaximumExclusive(value: unknown): value is unknown {
if(!isNumberValue(value)) {
return false;
}
return true;
}
export function isNumberAssertionMultipleOf(value: unknown): value is types.NumberAssertionMultipleOf {
if(!_isReferenceNumberAssertionMultipleOf(value)) {
return false;
}
return true;
}
function _isReferenceNumberAssertionMultipleOf(value: unknown): value is unknown {
if(!isNumberValue(value)) {
return false;
}
return true;
}
export function isStringAssertionOptions(value: unknown): value is types.StringAssertionOptions {
if(!_isArrayStringAssertionOptions(value)) {
return false;
}
return true;
}
function _isArrayStringAssertionOptions(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(!isStringAssertionOptionsItems(elementValue)) {
return false;
}
}
return true;
}
export function isMinimumLength(value: unknown): value is types.MinimumLength {
if(!_isReferenceMinimumLength(value)) {
return false;
}
return true;
}
function _isReferenceMinimumLength(value: unknown): value is unknown {
if(!isAmount(value)) {
return false;
}
return true;
}
export function isMaximumLength(value: unknown): value is types.MaximumLength {
if(!_isReferenceMaximumLength(value)) {
return false;
}
return true;
}
function _isReferenceMaximumLength(value: unknown): value is unknown {
if(!isAmount(value)) {
return false;
}
return true;
}
export function isValuePattern(value: unknown): value is types.ValuePattern {
if(!_isReferenceValuePattern(value)) {
return false;
}
return true;
}
function _isReferenceValuePattern(value: unknown): value is unknown {
if(!isNonEmptyStringValue(value)) {
return false;
}
return true;
}
export function isValueFormat(value: unknown): value is types.ValueFormat {
if(!_isReferenceValueFormat(value)) {
return false;
}
return true;
}
function _isReferenceValueFormat(value: unknown): value is unknown {
if(!isNonEmptyStringValue(value)) {
return false;
}
return true;
}
export function isMinimumItems(value: unknown): value is types.MinimumItems {
if(!_isReferenceMinimumItems(value)) {
return false;
}
return true;
}
function _isReferenceMinimumItems(value: unknown): value is unknown {
if(!isAmount(value)) {
return false;
}
return true;
}
export function isMaximumItems(value: unknown): value is types.MaximumItems {
if(!_isReferenceMaximumItems(value)) {
return false;
}
return true;
}
function _isReferenceMaximumItems(value: unknown): value is unknown {
if(!isAmount(value)) {
return false;
}
return true;
}
export function isUniqueItems(value: unknown): value is types.UniqueItems {
if(!_isBooleanUniqueItems(value)) {
return false;
}
return true;
}
function _isBooleanUniqueItems(value: unknown): value is unknown {
if(typeof value !== "boolean") {
return false;
}
return true;
}
export function isRequired(value: unknown): value is types.Required {
if(!_isArrayRequired(value)) {
return false;
}
return true;
}
function _isArrayRequired(value: unknown): value is unknown {
if(!Array.isArray(value)) {
return false;
}
const elementValueSeen = new Set<unknown>();
for(let elementIndex = 0; elementIndex < value.length; elementIndex ++) {
const elementValue = value[elementIndex];
if(elementValueSeen.has(elementValue)) {
return false;
}
elementValueSeen.add(elementValue);
if(!isRequiredItems(elementValue)) {
return false;
}
}
return true;
}
export function isMinimumProperties(value: unknown): value is types.MinimumProperties {
if(!_isReferenceMinimumProperties(value)) {
return false;
}
return true;
}
function _isReferenceMinimumProperties(value: unknown): value is unknown {
if(!isAmount(value)) {
return false;
}
return true;
}
export function isMaximumProperties(value: unknown): value is types.MaximumProperties {
if(!_isReferenceMaximumProperties(value)) {
return false;
}
return true;
}
function _isReferenceMaximumProperties(value: unknown): value is unknown {
if(!isAmount(value)) {
return false;
}
return true;
}
export function isSchemasAdditionalProperties(value: unknown): value is types.SchemasAdditionalProperties {
if(!_isReferenceSchemasAdditionalProperties(value)) {
return false;
}
return true;
}
function _isReferenceSchemasAdditionalProperties(value: unknown): value is unknown {
if(!isNode(value)) {
return false;
}
return true;
}
export function isExamplesItems(value: unknown): value is types.ExamplesItems {
if(!_isAnyExamplesItems(value)) {
return false;
}
return true;
}
function _isAnyExamplesItems(value: unknown): value is unknown {
return true;
}
export function isOneOfItems(value: unknown): value is types.OneOfItems {
if(!_isReferenceOneOfItems(value)) {
return false;
}
return true;
}
function _isReferenceOneOfItems(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isAnyOfItems(value: unknown): value is types.AnyOfItems {
if(!_isReferenceAnyOfItems(value)) {
return false;
}
return true;
}
function _isReferenceAnyOfItems(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isAllOfItems(value: unknown): value is types.AllOfItems {
if(!_isReferenceAllOfItems(value)) {
return false;
}
return true;
}
function _isReferenceAllOfItems(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isDependentSchemasAdditionalProperties(value: unknown): value is types.DependentSchemasAdditionalProperties {
if(!_isReferenceDependentSchemasAdditionalProperties(value)) {
return false;
}
return true;
}
function _isReferenceDependentSchemasAdditionalProperties(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isObjectPropertiesAdditionalProperties(value: unknown): value is types.ObjectPropertiesAdditionalProperties {
if(!_isReferenceObjectPropertiesAdditionalProperties(value)) {
return false;
}
return true;
}
function _isReferenceObjectPropertiesAdditionalProperties(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isPatternPropertiesAdditionalProperties(value: unknown): value is types.PatternPropertiesAdditionalProperties {
if(!_isReferencePatternPropertiesAdditionalProperties(value)) {
return false;
}
return true;
}
function _isReferencePatternPropertiesAdditionalProperties(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isTupleItemsItems(value: unknown): value is types.TupleItemsItems {
if(!_isReferenceTupleItemsItems(value)) {
return false;
}
return true;
}
function _isReferenceTupleItemsItems(value: unknown): value is unknown {
if(!isNodeReference(value)) {
return false;
}
return true;
}
export function isBooleanAssertionOptionsItems(value: unknown): value is types.BooleanAssertionOptionsItems {
if(!_isReferenceBooleanAssertionOptionsItems(value)) {
return false;
}
return true;
}
function _isReferenceBooleanAssertionOptionsItems(value: unknown): value is unknown {
if(!isBooleanValue(value)) {
return false;
}
return true;
}
export function isIntegerAssertionOptionsItems(value: unknown): value is types.IntegerAssertionOptionsItems {
if(!_isReferenceIntegerAssertionOptionsItems(value)) {
return false;
}
return true;
}
function _isReferenceIntegerAssertionOptionsItems(value: unknown): value is unknown {
if(!isIntegerValue(value)) {
return false;
}
return true;
}
export function isNumberAssertionOptionsItems(value: unknown): value is types.NumberAssertionOptionsItems {
if(!_isReferenceNumberAssertionOptionsItems(value)) {
return false;
}
return true;
}
function _isReferenceNumberAssertionOptionsItems(value: unknown): value is unknown {
if(!isNumberValue(value)) {
return false;
}
return true;
}
export function isStringAssertionOptionsItems(value: unknown): value is types.StringAssertionOptionsItems {
if(!_isReferenceStringAssertionOptionsItems(value)) {
return false;
}
return true;
}
function _isReferenceStringAssertionOptionsItems(value: unknown): value is unknown {
if(!isStringValue(value)) {
return false;
}
return true;
}
export function isRequiredItems(value: unknown): value is types.RequiredItems {
if(!_isReferenceRequiredItems(value)) {
return false;
}
return true;
}
function _isReferenceRequiredItems(value: unknown): value is unknown {
if(!isStringValue(value)) {
return false;
}
return true;
}
