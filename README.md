# JsonSchema42

Because JsonSchema is the answer to everything!

## Installing

First, install dependencies via `npm install`.

## Building

You might want to build The project via `npm --workspaces run build`. This is automatically done before testing and packaging.

## Generating

The generator uses code that is generated by the generator (!). To regenerate, use make via the `make` command.

But...

This might also update the `package-lock.json` file to use the local, generated code in stead of the published code. Don't check in this new generated `package-lock.json`. It will ruin the install experience in a fresh repo. This might break ci.

So use this only for debugging! And make sure you know what you are doing.

## Publishing

Bump version via `npm --workspaces version patch`. You could also bump a minor or major version.

Then regenerate code via `make rebuild`.

Then update dependencies via `npm --workspaces update --save`, or do this manually.

The publish everything via `npm --workspaces publish`.

Then commit and push everything to git. Do make sure that the `package-lock.json` does not reference the generated code!

## Design

How do things work.

### Overview

The generation of code from a schema goes through the following steps:

1.  Loading

    The schema is loaded, then all referenced schemas are loaded. Every schema (embedded and referenced) is represented as a document. Depending on the version of the schema the document is of a different class. The document context is responsible for managing this.

    This is done via a cache. All nodes that are retrieved (loaded) are cached first. Then documents are created from the cache.

2.  Reading

    The document is read and normalized into an intermediate document. In this document all of the nodes, including external nodes are represented.

3.  Importing

    The intermediate document is translated into the schema arena. One of the most interesting aspects is that the nodes in the intermediate document have an identifier that is a string (a location). In the arena the nodes have a key that is an identifier. Depending on the requirements the node can be imported in multiple arenas.

4.  Optimization

    Node in an arena are optimized so that they do not contain anything that we cannot handle later. For instance, the if, then, else fields may be resolved, or the anyOf fields may be resolved. Depending on the arena, different types optimization may be used.

5.  Naming

    The nodes in an arena may be names based on their id or context. These names are later used to generate type names or function names. Names are categorized in primary and secondary names. Primary names are probably going to be used by the end user, secondary names are probably never going to be used. Secondary names are names that have an id, but are not a descendant of the root of the schema. This can happen as a result of an optimization. We need the secondary

    In general naming is constructed from the path parts and the pointer parts of a location and the context of the node. Every node has some parts that are then given an cardinality in their context (arena and category). The names are then constructed from the last part or the part with the lowest cardinality. If this name is not unique then the next part is added until we have unique names. If the names are not unique until a limit is reached then every name is prefixed with a number to enforce uniqueness.

6.  Code generation

    The last step is the actual code generation. Code is generated from the arena(s) and the names(s) that are generated from the arenas.
