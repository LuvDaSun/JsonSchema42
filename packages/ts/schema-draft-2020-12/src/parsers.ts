// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.12.7                         -- www.JsonSchema42.org
//
import * as types from "./types.js";
export interface ParserGeneratorOptions {
trueStringValues?: string[];
falseStringValues?: string[];
}
const defaultParserGeneratorOptions = {
trueStringValues: ["", "true", "yes", "on", "1"],
falseStringValues: ["false", "no", "off", "0"],
}
/**
* @summary Core and Validation specifications meta-schema
* @see {@link https://json-schema.org/draft/2020-12/schema}
*/
export function parseSchema(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "$id":
return [
name,
parseId(value, configuration),
]
case "$schema":
return [
name,
parseCoreSchema(value, configuration),
]
case "$ref":
return [
name,
parseRef(value, configuration),
]
case "$anchor":
return [
name,
parseAnchor(value, configuration),
]
case "$dynamicRef":
return [
name,
parseDynamicRef(value, configuration),
]
case "$dynamicAnchor":
return [
name,
parseDynamicAnchor(value, configuration),
]
case "$vocabulary":
return [
name,
parseVocabulary(value, configuration),
]
case "$comment":
return [
name,
parseComment(value, configuration),
]
case "$defs":
return [
name,
parseDefs(value, configuration),
]
case "prefixItems":
return [
name,
parsePrefixItems(value, configuration),
]
case "items":
return [
name,
parseApplicatorItems(value, configuration),
]
case "contains":
return [
name,
parseContains(value, configuration),
]
case "additionalProperties":
return [
name,
parseApplicatorAdditionalProperties(value, configuration),
]
case "properties":
return [
name,
parseProperties(value, configuration),
]
case "patternProperties":
return [
name,
parsePatternProperties(value, configuration),
]
case "dependentSchemas":
return [
name,
parseDependentSchemas(value, configuration),
]
case "propertyNames":
return [
name,
parseApplicatorPropertyNames(value, configuration),
]
case "if":
return [
name,
parseIf(value, configuration),
]
case "then":
return [
name,
parseThen(value, configuration),
]
case "else":
return [
name,
parseElse(value, configuration),
]
case "allOf":
return [
name,
parseAllOf(value, configuration),
]
case "anyOf":
return [
name,
parseAnyOf(value, configuration),
]
case "oneOf":
return [
name,
parseOneOf(value, configuration),
]
case "not":
return [
name,
parseNot(value, configuration),
]
case "unevaluatedItems":
return [
name,
parseUnevaluatedItems(value, configuration),
]
case "unevaluatedProperties":
return [
name,
parseUnevaluatedProperties(value, configuration),
]
case "type":
return [
name,
parseType(value, configuration),
]
case "const":
return [
name,
parseConst(value, configuration),
]
case "enum":
return [
name,
parseEnum(value, configuration),
]
case "multipleOf":
return [
name,
parseMultipleOf(value, configuration),
]
case "maximum":
return [
name,
parseMaximum(value, configuration),
]
case "exclusiveMaximum":
return [
name,
parseExclusiveMaximum(value, configuration),
]
case "minimum":
return [
name,
parseMinimum(value, configuration),
]
case "exclusiveMinimum":
return [
name,
parseExclusiveMinimum(value, configuration),
]
case "maxLength":
return [
name,
parseMaxLength(value, configuration),
]
case "minLength":
return [
name,
parseMinLength(value, configuration),
]
case "pattern":
return [
name,
parsePattern(value, configuration),
]
case "maxItems":
return [
name,
parseMaxItems(value, configuration),
]
case "minItems":
return [
name,
parseMinItems(value, configuration),
]
case "uniqueItems":
return [
name,
parseUniqueItems(value, configuration),
]
case "maxContains":
return [
name,
parseMaxContains(value, configuration),
]
case "minContains":
return [
name,
parseMinContains(value, configuration),
]
case "maxProperties":
return [
name,
parseMaxProperties(value, configuration),
]
case "minProperties":
return [
name,
parseMinProperties(value, configuration),
]
case "required":
return [
name,
parseRequired(value, configuration),
]
case "dependentRequired":
return [
name,
parseDependentRequired(value, configuration),
]
case "title":
return [
name,
parseTitle(value, configuration),
]
case "description":
return [
name,
parseDescription(value, configuration),
]
case "default":
return [
name,
parseDefault(value, configuration),
]
case "deprecated":
return [
name,
parseDeprecated(value, configuration),
]
case "readOnly":
return [
name,
parseReadOnly(value, configuration),
]
case "writeOnly":
return [
name,
parseWriteOnly(value, configuration),
]
case "examples":
return [
name,
parseExamples(value, configuration),
]
case "format":
return [
name,
parseFormat(value, configuration),
]
case "contentEncoding":
return [
name,
parseContentEncoding(value, configuration),
]
case "contentMediaType":
return [
name,
parseContentMediaType(value, configuration),
]
case "contentSchema":
return [
name,
parseContentSchema(value, configuration),
]
case "definitions":
return [
name,
parseDefinitions(value, configuration),
]
case "dependencies":
return [
name,
parseDependencies(value, configuration),
]
case "$recursiveAnchor":
return [
name,
parseRecursiveAnchor(value, configuration),
]
case "$recursiveRef":
return [
name,
parseRecursiveRef(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/definitions}
* @deprecated
*/
export function parseDefinitions(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parseDefinitionsAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/dependencies}
* @deprecated
*/
export function parseDependencies(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parseDependenciesAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/$recursiveAnchor}
* @deprecated
*/
export function parseRecursiveAnchor(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseAnchorString(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/$recursiveRef}
* @deprecated
*/
export function parseRecursiveRef(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseUriReferenceString(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/allOf/0}
*/
export function parseAllOf0(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseCore(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/allOf/1}
*/
export function parseAllOf1(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseApplicator(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/allOf/2}
*/
export function parseAllOf2(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseUnevaluated(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/allOf/3}
*/
export function parseAllOf3(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseValidation(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/allOf/4}
*/
export function parseAllOf4(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseMetaData(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/allOf/5}
*/
export function parseAllOf5(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseFormatAnnotation(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/allOf/6}
*/
export function parseAllOf6(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseContent(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/definitions/additionalProperties}
*/
export function parseDefinitionsAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/dependencies/additionalProperties}
*/
export function parseDependenciesAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
parseStringArray(value, configuration)
??
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "$id":
return [
name,
parseId(value, configuration),
]
case "$schema":
return [
name,
parseCoreSchema(value, configuration),
]
case "$ref":
return [
name,
parseRef(value, configuration),
]
case "$anchor":
return [
name,
parseAnchor(value, configuration),
]
case "$dynamicRef":
return [
name,
parseDynamicRef(value, configuration),
]
case "$dynamicAnchor":
return [
name,
parseDynamicAnchor(value, configuration),
]
case "$vocabulary":
return [
name,
parseVocabulary(value, configuration),
]
case "$comment":
return [
name,
parseComment(value, configuration),
]
case "$defs":
return [
name,
parseDefs(value, configuration),
]
case "prefixItems":
return [
name,
parsePrefixItems(value, configuration),
]
case "items":
return [
name,
parseApplicatorItems(value, configuration),
]
case "contains":
return [
name,
parseContains(value, configuration),
]
case "additionalProperties":
return [
name,
parseApplicatorAdditionalProperties(value, configuration),
]
case "properties":
return [
name,
parseProperties(value, configuration),
]
case "patternProperties":
return [
name,
parsePatternProperties(value, configuration),
]
case "dependentSchemas":
return [
name,
parseDependentSchemas(value, configuration),
]
case "propertyNames":
return [
name,
parseApplicatorPropertyNames(value, configuration),
]
case "if":
return [
name,
parseIf(value, configuration),
]
case "then":
return [
name,
parseThen(value, configuration),
]
case "else":
return [
name,
parseElse(value, configuration),
]
case "allOf":
return [
name,
parseAllOf(value, configuration),
]
case "anyOf":
return [
name,
parseAnyOf(value, configuration),
]
case "oneOf":
return [
name,
parseOneOf(value, configuration),
]
case "not":
return [
name,
parseNot(value, configuration),
]
case "unevaluatedItems":
return [
name,
parseUnevaluatedItems(value, configuration),
]
case "unevaluatedProperties":
return [
name,
parseUnevaluatedProperties(value, configuration),
]
case "type":
return [
name,
parseType(value, configuration),
]
case "const":
return [
name,
parseConst(value, configuration),
]
case "enum":
return [
name,
parseEnum(value, configuration),
]
case "multipleOf":
return [
name,
parseMultipleOf(value, configuration),
]
case "maximum":
return [
name,
parseMaximum(value, configuration),
]
case "exclusiveMaximum":
return [
name,
parseExclusiveMaximum(value, configuration),
]
case "minimum":
return [
name,
parseMinimum(value, configuration),
]
case "exclusiveMinimum":
return [
name,
parseExclusiveMinimum(value, configuration),
]
case "maxLength":
return [
name,
parseMaxLength(value, configuration),
]
case "minLength":
return [
name,
parseMinLength(value, configuration),
]
case "pattern":
return [
name,
parsePattern(value, configuration),
]
case "maxItems":
return [
name,
parseMaxItems(value, configuration),
]
case "minItems":
return [
name,
parseMinItems(value, configuration),
]
case "uniqueItems":
return [
name,
parseUniqueItems(value, configuration),
]
case "maxContains":
return [
name,
parseMaxContains(value, configuration),
]
case "minContains":
return [
name,
parseMinContains(value, configuration),
]
case "maxProperties":
return [
name,
parseMaxProperties(value, configuration),
]
case "minProperties":
return [
name,
parseMinProperties(value, configuration),
]
case "required":
return [
name,
parseRequired(value, configuration),
]
case "dependentRequired":
return [
name,
parseDependentRequired(value, configuration),
]
case "title":
return [
name,
parseTitle(value, configuration),
]
case "description":
return [
name,
parseDescription(value, configuration),
]
case "default":
return [
name,
parseDefault(value, configuration),
]
case "deprecated":
return [
name,
parseDeprecated(value, configuration),
]
case "readOnly":
return [
name,
parseReadOnly(value, configuration),
]
case "writeOnly":
return [
name,
parseWriteOnly(value, configuration),
]
case "examples":
return [
name,
parseExamples(value, configuration),
]
case "format":
return [
name,
parseFormat(value, configuration),
]
case "contentEncoding":
return [
name,
parseContentEncoding(value, configuration),
]
case "contentMediaType":
return [
name,
parseContentMediaType(value, configuration),
]
case "contentSchema":
return [
name,
parseContentSchema(value, configuration),
]
case "definitions":
return [
name,
parseDefinitions(value, configuration),
]
case "dependencies":
return [
name,
parseDependencies(value, configuration),
]
case "$recursiveAnchor":
return [
name,
parseRecursiveAnchor(value, configuration),
]
case "$recursiveRef":
return [
name,
parseRecursiveRef(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/dependencies/additionalProperties/anyOf/0}
*/
export function parseDependencies0(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/schema#/properties/dependencies/additionalProperties/anyOf/1}
*/
export function parseDependencies1(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseStringArray(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/$defs/anchorString}
*/
export function parseAnchorString(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/$defs/uriReferenceString}
*/
export function parseUriReferenceString(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @summary Core vocabulary meta-schema
* @see {@link https://json-schema.org/draft/2020-12/meta/core}
*/
export function parseCore(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "$id":
return [
name,
parseId(value, configuration),
]
case "$schema":
return [
name,
parseCoreSchema(value, configuration),
]
case "$ref":
return [
name,
parseRef(value, configuration),
]
case "$anchor":
return [
name,
parseAnchor(value, configuration),
]
case "$dynamicRef":
return [
name,
parseDynamicRef(value, configuration),
]
case "$dynamicAnchor":
return [
name,
parseDynamicAnchor(value, configuration),
]
case "$vocabulary":
return [
name,
parseVocabulary(value, configuration),
]
case "$comment":
return [
name,
parseComment(value, configuration),
]
case "$defs":
return [
name,
parseDefs(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/$defs/uriString}
*/
export function parseUriString(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$id}
*/
export function parseId(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$schema}
*/
export function parseCoreSchema(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseUriString(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$ref}
*/
export function parseRef(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseUriReferenceString(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$anchor}
*/
export function parseAnchor(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseAnchorString(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$dynamicRef}
*/
export function parseDynamicRef(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseUriReferenceString(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$dynamicAnchor}
*/
export function parseDynamicAnchor(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseAnchorString(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$vocabulary}
*/
export function parseVocabulary(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parseVocabularyAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$comment}
*/
export function parseComment(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$defs}
*/
export function parseDefs(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parseDefsAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$vocabulary/additionalProperties}
*/
export function parseVocabularyAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$vocabulary/propertyNames}
*/
export function parseVocabularyPropertyNames(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/core#/properties/$defs/additionalProperties}
*/
export function parseDefsAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @summary Applicator vocabulary meta-schema
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator}
*/
export function parseApplicator(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "prefixItems":
return [
name,
parsePrefixItems(value, configuration),
]
case "items":
return [
name,
parseApplicatorItems(value, configuration),
]
case "contains":
return [
name,
parseContains(value, configuration),
]
case "additionalProperties":
return [
name,
parseApplicatorAdditionalProperties(value, configuration),
]
case "properties":
return [
name,
parseProperties(value, configuration),
]
case "patternProperties":
return [
name,
parsePatternProperties(value, configuration),
]
case "dependentSchemas":
return [
name,
parseDependentSchemas(value, configuration),
]
case "propertyNames":
return [
name,
parseApplicatorPropertyNames(value, configuration),
]
case "if":
return [
name,
parseIf(value, configuration),
]
case "then":
return [
name,
parseThen(value, configuration),
]
case "else":
return [
name,
parseElse(value, configuration),
]
case "allOf":
return [
name,
parseAllOf(value, configuration),
]
case "anyOf":
return [
name,
parseAnyOf(value, configuration),
]
case "oneOf":
return [
name,
parseOneOf(value, configuration),
]
case "not":
return [
name,
parseNot(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/$defs/schemaArray}
*/
export function parseSchemaArray(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
Array.isArray(value) ?
value.map((value, index) => {
switch(index) {
default:
return parseSchemaArrayItems(value, configuration)
}
}) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/prefixItems}
*/
export function parsePrefixItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchemaArray(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/items}
*/
export function parseApplicatorItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/contains}
*/
export function parseContains(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/additionalProperties}
*/
export function parseApplicatorAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/properties}
*/
export function parseProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parsePropertiesAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/patternProperties}
*/
export function parsePatternProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parsePatternPropertiesAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/dependentSchemas}
*/
export function parseDependentSchemas(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parseDependentSchemasAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/propertyNames}
*/
export function parseApplicatorPropertyNames(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/if}
*/
export function parseIf(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/then}
*/
export function parseThen(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/else}
*/
export function parseElse(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/allOf}
*/
export function parseAllOf(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchemaArray(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/anyOf}
*/
export function parseAnyOf(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchemaArray(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/oneOf}
*/
export function parseOneOf(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchemaArray(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/not}
*/
export function parseNot(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/$defs/schemaArray/items}
*/
export function parseSchemaArrayItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/properties/additionalProperties}
*/
export function parsePropertiesAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/patternProperties/additionalProperties}
*/
export function parsePatternPropertiesAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/patternProperties/propertyNames}
*/
export function parsePatternPropertiesPropertyNames(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/applicator#/properties/dependentSchemas/additionalProperties}
*/
export function parseDependentSchemasAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @summary Unevaluated applicator vocabulary meta-schema
* @see {@link https://json-schema.org/draft/2020-12/meta/unevaluated}
*/
export function parseUnevaluated(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "unevaluatedItems":
return [
name,
parseUnevaluatedItems(value, configuration),
]
case "unevaluatedProperties":
return [
name,
parseUnevaluatedProperties(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/unevaluated#/properties/unevaluatedItems}
*/
export function parseUnevaluatedItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/unevaluated#/properties/unevaluatedProperties}
*/
export function parseUnevaluatedProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
/**
* @summary Validation vocabulary meta-schema
* @see {@link https://json-schema.org/draft/2020-12/meta/validation}
*/
export function parseValidation(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "type":
return [
name,
parseType(value, configuration),
]
case "const":
return [
name,
parseConst(value, configuration),
]
case "enum":
return [
name,
parseEnum(value, configuration),
]
case "multipleOf":
return [
name,
parseMultipleOf(value, configuration),
]
case "maximum":
return [
name,
parseMaximum(value, configuration),
]
case "exclusiveMaximum":
return [
name,
parseExclusiveMaximum(value, configuration),
]
case "minimum":
return [
name,
parseMinimum(value, configuration),
]
case "exclusiveMinimum":
return [
name,
parseExclusiveMinimum(value, configuration),
]
case "maxLength":
return [
name,
parseMaxLength(value, configuration),
]
case "minLength":
return [
name,
parseMinLength(value, configuration),
]
case "pattern":
return [
name,
parsePattern(value, configuration),
]
case "maxItems":
return [
name,
parseMaxItems(value, configuration),
]
case "minItems":
return [
name,
parseMinItems(value, configuration),
]
case "uniqueItems":
return [
name,
parseUniqueItems(value, configuration),
]
case "maxContains":
return [
name,
parseMaxContains(value, configuration),
]
case "minContains":
return [
name,
parseMinContains(value, configuration),
]
case "maxProperties":
return [
name,
parseMaxProperties(value, configuration),
]
case "minProperties":
return [
name,
parseMinProperties(value, configuration),
]
case "required":
return [
name,
parseRequired(value, configuration),
]
case "dependentRequired":
return [
name,
parseDependentRequired(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/$defs/nonNegativeInteger}
*/
export function parseNonNegativeInteger(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/$defs/nonNegativeIntegerDefault0}
*/
export function parseNonNegativeIntegerDefault0(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeInteger(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/$defs/simpleTypes}
*/
export function parseSimpleTypes(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (value);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/$defs/stringArray}
*/
export function parseStringArray(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
Array.isArray(value) ?
value.map((value, index) => {
switch(index) {
default:
return parseStringArrayItems(value, configuration)
}
}) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/type}
*/
export function parseType(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (value);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/const}
*/
export function parseConst(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (value);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/enum}
*/
export function parseEnum(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
Array.isArray(value) ?
value.map((value, index) => {
switch(index) {
default:
return parseEnumItems(value, configuration)
}
}) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/multipleOf}
*/
export function parseMultipleOf(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/maximum}
*/
export function parseMaximum(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/exclusiveMaximum}
*/
export function parseExclusiveMaximum(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/minimum}
*/
export function parseMinimum(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/exclusiveMinimum}
*/
export function parseExclusiveMinimum(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/maxLength}
*/
export function parseMaxLength(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeInteger(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/minLength}
*/
export function parseMinLength(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeIntegerDefault0(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/pattern}
*/
export function parsePattern(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/maxItems}
*/
export function parseMaxItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeInteger(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/minItems}
*/
export function parseMinItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeIntegerDefault0(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/uniqueItems}
*/
export function parseUniqueItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/maxContains}
*/
export function parseMaxContains(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeInteger(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/minContains}
*/
export function parseMinContains(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeInteger(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/maxProperties}
*/
export function parseMaxProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeInteger(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/minProperties}
*/
export function parseMinProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseNonNegativeIntegerDefault0(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/required}
*/
export function parseRequired(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseStringArray(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/dependentRequired}
*/
export function parseDependentRequired(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
default:
return [
name,
(parseDependentRequiredAdditionalProperties(value, configuration)),
]
}
})
) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/$defs/stringArray/items}
*/
export function parseStringArrayItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/type/anyOf/0}
*/
export function parseType0(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSimpleTypes(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/type/anyOf/1}
*/
export function parseType1(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
Array.isArray(value) ?
value.map((value, index) => {
switch(index) {
default:
return parseTypeItems(value, configuration)
}
}) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/enum/items}
*/
export function parseEnumItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (value);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/dependentRequired/additionalProperties}
*/
export function parseDependentRequiredAdditionalProperties(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseStringArray(value, configuration));
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/validation#/properties/type/anyOf/1/items}
*/
export function parseTypeItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSimpleTypes(value, configuration));
}
/**
* @summary Meta-data vocabulary meta-schema
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data}
*/
export function parseMetaData(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "title":
return [
name,
parseTitle(value, configuration),
]
case "description":
return [
name,
parseDescription(value, configuration),
]
case "default":
return [
name,
parseDefault(value, configuration),
]
case "deprecated":
return [
name,
parseDeprecated(value, configuration),
]
case "readOnly":
return [
name,
parseReadOnly(value, configuration),
]
case "writeOnly":
return [
name,
parseWriteOnly(value, configuration),
]
case "examples":
return [
name,
parseExamples(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/title}
*/
export function parseTitle(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/description}
*/
export function parseDescription(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/default}
*/
export function parseDefault(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (value);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/deprecated}
*/
export function parseDeprecated(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/readOnly}
*/
export function parseReadOnly(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/writeOnly}
*/
export function parseWriteOnly(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/examples}
*/
export function parseExamples(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
Array.isArray(value) ?
value.map((value, index) => {
switch(index) {
default:
return parseExamplesItems(value, configuration)
}
}) :
undefined
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/meta-data#/properties/examples/items}
*/
export function parseExamplesItems(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (value);
}
/**
* @summary Format vocabulary meta-schema for annotation results
* @see {@link https://json-schema.org/draft/2020-12/meta/format-annotation}
*/
export function parseFormatAnnotation(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "format":
return [
name,
parseFormat(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/format-annotation#/properties/format}
*/
export function parseFormat(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @summary Content vocabulary meta-schema
* @see {@link https://json-schema.org/draft/2020-12/meta/content}
*/
export function parseContent(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
(
(typeof value === "object" && value !== null && !Array.isArray(value)) ?
Object.fromEntries(
Object.entries(value).map(([name, value]) => {
switch(name) {
case "contentEncoding":
return [
name,
parseContentEncoding(value, configuration),
]
case "contentMediaType":
return [
name,
parseContentMediaType(value, configuration),
]
case "contentSchema":
return [
name,
parseContentSchema(value, configuration),
]
default:
return value;
}
})
) :
undefined
)
??
(
((value: unknown) => {
if(value == null) {
return false;
}
if(Array.isArray(value)) {
switch(value.length) {
case 0:
return false;
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
value = value.trim();
for(const trueStringValue of configuration.trueStringValues) {
if(value === trueStringValue) {
return true;
}
}
for(const falseStringValue of configuration.falseStringValues) {
if(value === falseStringValue) {
return false;
}
}
return undefined;
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
})(value)
)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/content#/properties/contentEncoding}
*/
export function parseContentEncoding(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/content#/properties/contentMediaType}
*/
export function parseContentMediaType(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (
((value: unknown) => {
if(Array.isArray(value)) {
switch(value.length) {
case 1:
[value] = value
break;
default:
return undefined;
}
}
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
})(value)
);
}
/**
* @see {@link https://json-schema.org/draft/2020-12/meta/content#/properties/contentSchema}
*/
export function parseContentSchema(value: unknown, options: ParserGeneratorOptions = {}): unknown {
const configuration = {
...defaultParserGeneratorOptions,
...options,
};
return (parseSchema(value, configuration));
}
