// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.11.8                         -- www.JsonSchema42.org
//
import assert from "node:assert/strict";
import test from "node:test";
import * as validators from "./validators.js";
import * as mocks from "./mocks.js";
test.skip("Schema", () => {
const mock = mocks.mockSchema();
const valid = validators.isSchema(mock);
assert.equal(valid, true);
});
test.skip("Definitions", () => {
const mock = mocks.mockDefinitions();
const valid = validators.isDefinitions(mock);
assert.equal(valid, true);
});
test.skip("Dependencies", () => {
const mock = mocks.mockDependencies();
const valid = validators.isDependencies(mock);
assert.equal(valid, true);
});
test.skip("RecursiveAnchor", () => {
const mock = mocks.mockRecursiveAnchor();
const valid = validators.isRecursiveAnchor(mock);
assert.equal(valid, true);
});
test.skip("RecursiveRef", () => {
const mock = mocks.mockRecursiveRef();
const valid = validators.isRecursiveRef(mock);
assert.equal(valid, true);
});
test.skip("AllOf0", () => {
const mock = mocks.mockAllOf0();
const valid = validators.isAllOf0(mock);
assert.equal(valid, true);
});
test.skip("AllOf1", () => {
const mock = mocks.mockAllOf1();
const valid = validators.isAllOf1(mock);
assert.equal(valid, true);
});
test.skip("AllOf2", () => {
const mock = mocks.mockAllOf2();
const valid = validators.isAllOf2(mock);
assert.equal(valid, true);
});
test.skip("AllOf3", () => {
const mock = mocks.mockAllOf3();
const valid = validators.isAllOf3(mock);
assert.equal(valid, true);
});
test.skip("AllOf4", () => {
const mock = mocks.mockAllOf4();
const valid = validators.isAllOf4(mock);
assert.equal(valid, true);
});
test.skip("AllOf5", () => {
const mock = mocks.mockAllOf5();
const valid = validators.isAllOf5(mock);
assert.equal(valid, true);
});
test.skip("AllOf6", () => {
const mock = mocks.mockAllOf6();
const valid = validators.isAllOf6(mock);
assert.equal(valid, true);
});
test.skip("DefinitionsAdditionalProperties", () => {
const mock = mocks.mockDefinitionsAdditionalProperties();
const valid = validators.isDefinitionsAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("DependenciesAdditionalProperties", () => {
const mock = mocks.mockDependenciesAdditionalProperties();
const valid = validators.isDependenciesAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("Dependencies0", () => {
const mock = mocks.mockDependencies0();
const valid = validators.isDependencies0(mock);
assert.equal(valid, true);
});
test.skip("Dependencies1", () => {
const mock = mocks.mockDependencies1();
const valid = validators.isDependencies1(mock);
assert.equal(valid, true);
});
test.skip("AnchorString", () => {
const mock = mocks.mockAnchorString();
const valid = validators.isAnchorString(mock);
assert.equal(valid, true);
});
test.skip("UriReferenceString", () => {
const mock = mocks.mockUriReferenceString();
const valid = validators.isUriReferenceString(mock);
assert.equal(valid, true);
});
test.skip("Core", () => {
const mock = mocks.mockCore();
const valid = validators.isCore(mock);
assert.equal(valid, true);
});
test.skip("UriString", () => {
const mock = mocks.mockUriString();
const valid = validators.isUriString(mock);
assert.equal(valid, true);
});
test.skip("Id", () => {
const mock = mocks.mockId();
const valid = validators.isId(mock);
assert.equal(valid, true);
});
test.skip("CoreSchema", () => {
const mock = mocks.mockCoreSchema();
const valid = validators.isCoreSchema(mock);
assert.equal(valid, true);
});
test.skip("Ref", () => {
const mock = mocks.mockRef();
const valid = validators.isRef(mock);
assert.equal(valid, true);
});
test.skip("Anchor", () => {
const mock = mocks.mockAnchor();
const valid = validators.isAnchor(mock);
assert.equal(valid, true);
});
test.skip("DynamicRef", () => {
const mock = mocks.mockDynamicRef();
const valid = validators.isDynamicRef(mock);
assert.equal(valid, true);
});
test.skip("DynamicAnchor", () => {
const mock = mocks.mockDynamicAnchor();
const valid = validators.isDynamicAnchor(mock);
assert.equal(valid, true);
});
test.skip("Vocabulary", () => {
const mock = mocks.mockVocabulary();
const valid = validators.isVocabulary(mock);
assert.equal(valid, true);
});
test.skip("Comment", () => {
const mock = mocks.mockComment();
const valid = validators.isComment(mock);
assert.equal(valid, true);
});
test.skip("Defs", () => {
const mock = mocks.mockDefs();
const valid = validators.isDefs(mock);
assert.equal(valid, true);
});
test.skip("VocabularyAdditionalProperties", () => {
const mock = mocks.mockVocabularyAdditionalProperties();
const valid = validators.isVocabularyAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("VocabularyPropertyNames", () => {
const mock = mocks.mockVocabularyPropertyNames();
const valid = validators.isVocabularyPropertyNames(mock);
assert.equal(valid, true);
});
test.skip("DefsAdditionalProperties", () => {
const mock = mocks.mockDefsAdditionalProperties();
const valid = validators.isDefsAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("Applicator", () => {
const mock = mocks.mockApplicator();
const valid = validators.isApplicator(mock);
assert.equal(valid, true);
});
test.skip("SchemaArray", () => {
const mock = mocks.mockSchemaArray();
const valid = validators.isSchemaArray(mock);
assert.equal(valid, true);
});
test.skip("PrefixItems", () => {
const mock = mocks.mockPrefixItems();
const valid = validators.isPrefixItems(mock);
assert.equal(valid, true);
});
test.skip("ApplicatorItems", () => {
const mock = mocks.mockApplicatorItems();
const valid = validators.isApplicatorItems(mock);
assert.equal(valid, true);
});
test.skip("Contains", () => {
const mock = mocks.mockContains();
const valid = validators.isContains(mock);
assert.equal(valid, true);
});
test.skip("ApplicatorAdditionalProperties", () => {
const mock = mocks.mockApplicatorAdditionalProperties();
const valid = validators.isApplicatorAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("Properties", () => {
const mock = mocks.mockProperties();
const valid = validators.isProperties(mock);
assert.equal(valid, true);
});
test.skip("PatternProperties", () => {
const mock = mocks.mockPatternProperties();
const valid = validators.isPatternProperties(mock);
assert.equal(valid, true);
});
test.skip("DependentSchemas", () => {
const mock = mocks.mockDependentSchemas();
const valid = validators.isDependentSchemas(mock);
assert.equal(valid, true);
});
test.skip("ApplicatorPropertyNames", () => {
const mock = mocks.mockApplicatorPropertyNames();
const valid = validators.isApplicatorPropertyNames(mock);
assert.equal(valid, true);
});
test.skip("If", () => {
const mock = mocks.mockIf();
const valid = validators.isIf(mock);
assert.equal(valid, true);
});
test.skip("Then", () => {
const mock = mocks.mockThen();
const valid = validators.isThen(mock);
assert.equal(valid, true);
});
test.skip("Else", () => {
const mock = mocks.mockElse();
const valid = validators.isElse(mock);
assert.equal(valid, true);
});
test.skip("AllOf", () => {
const mock = mocks.mockAllOf();
const valid = validators.isAllOf(mock);
assert.equal(valid, true);
});
test.skip("AnyOf", () => {
const mock = mocks.mockAnyOf();
const valid = validators.isAnyOf(mock);
assert.equal(valid, true);
});
test.skip("OneOf", () => {
const mock = mocks.mockOneOf();
const valid = validators.isOneOf(mock);
assert.equal(valid, true);
});
test.skip("Not", () => {
const mock = mocks.mockNot();
const valid = validators.isNot(mock);
assert.equal(valid, true);
});
test.skip("SchemaArrayItems", () => {
const mock = mocks.mockSchemaArrayItems();
const valid = validators.isSchemaArrayItems(mock);
assert.equal(valid, true);
});
test.skip("PropertiesAdditionalProperties", () => {
const mock = mocks.mockPropertiesAdditionalProperties();
const valid = validators.isPropertiesAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("PatternPropertiesAdditionalProperties", () => {
const mock = mocks.mockPatternPropertiesAdditionalProperties();
const valid = validators.isPatternPropertiesAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("PatternPropertiesPropertyNames", () => {
const mock = mocks.mockPatternPropertiesPropertyNames();
const valid = validators.isPatternPropertiesPropertyNames(mock);
assert.equal(valid, true);
});
test.skip("DependentSchemasAdditionalProperties", () => {
const mock = mocks.mockDependentSchemasAdditionalProperties();
const valid = validators.isDependentSchemasAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("Unevaluated", () => {
const mock = mocks.mockUnevaluated();
const valid = validators.isUnevaluated(mock);
assert.equal(valid, true);
});
test.skip("UnevaluatedItems", () => {
const mock = mocks.mockUnevaluatedItems();
const valid = validators.isUnevaluatedItems(mock);
assert.equal(valid, true);
});
test.skip("UnevaluatedProperties", () => {
const mock = mocks.mockUnevaluatedProperties();
const valid = validators.isUnevaluatedProperties(mock);
assert.equal(valid, true);
});
test.skip("Validation", () => {
const mock = mocks.mockValidation();
const valid = validators.isValidation(mock);
assert.equal(valid, true);
});
test.skip("NonNegativeInteger", () => {
const mock = mocks.mockNonNegativeInteger();
const valid = validators.isNonNegativeInteger(mock);
assert.equal(valid, true);
});
test.skip("NonNegativeIntegerDefault0", () => {
const mock = mocks.mockNonNegativeIntegerDefault0();
const valid = validators.isNonNegativeIntegerDefault0(mock);
assert.equal(valid, true);
});
test.skip("SimpleTypes", () => {
const mock = mocks.mockSimpleTypes();
const valid = validators.isSimpleTypes(mock);
assert.equal(valid, true);
});
test.skip("StringArray", () => {
const mock = mocks.mockStringArray();
const valid = validators.isStringArray(mock);
assert.equal(valid, true);
});
test.skip("Type", () => {
const mock = mocks.mockType();
const valid = validators.isType(mock);
assert.equal(valid, true);
});
test.skip("Const", () => {
const mock = mocks.mockConst();
const valid = validators.isConst(mock);
assert.equal(valid, true);
});
test.skip("Enum", () => {
const mock = mocks.mockEnum();
const valid = validators.isEnum(mock);
assert.equal(valid, true);
});
test.skip("MultipleOf", () => {
const mock = mocks.mockMultipleOf();
const valid = validators.isMultipleOf(mock);
assert.equal(valid, true);
});
test.skip("Maximum", () => {
const mock = mocks.mockMaximum();
const valid = validators.isMaximum(mock);
assert.equal(valid, true);
});
test.skip("ExclusiveMaximum", () => {
const mock = mocks.mockExclusiveMaximum();
const valid = validators.isExclusiveMaximum(mock);
assert.equal(valid, true);
});
test.skip("Minimum", () => {
const mock = mocks.mockMinimum();
const valid = validators.isMinimum(mock);
assert.equal(valid, true);
});
test.skip("ExclusiveMinimum", () => {
const mock = mocks.mockExclusiveMinimum();
const valid = validators.isExclusiveMinimum(mock);
assert.equal(valid, true);
});
test.skip("MaxLength", () => {
const mock = mocks.mockMaxLength();
const valid = validators.isMaxLength(mock);
assert.equal(valid, true);
});
test.skip("MinLength", () => {
const mock = mocks.mockMinLength();
const valid = validators.isMinLength(mock);
assert.equal(valid, true);
});
test.skip("Pattern", () => {
const mock = mocks.mockPattern();
const valid = validators.isPattern(mock);
assert.equal(valid, true);
});
test.skip("MaxItems", () => {
const mock = mocks.mockMaxItems();
const valid = validators.isMaxItems(mock);
assert.equal(valid, true);
});
test.skip("MinItems", () => {
const mock = mocks.mockMinItems();
const valid = validators.isMinItems(mock);
assert.equal(valid, true);
});
test.skip("UniqueItems", () => {
const mock = mocks.mockUniqueItems();
const valid = validators.isUniqueItems(mock);
assert.equal(valid, true);
});
test.skip("MaxContains", () => {
const mock = mocks.mockMaxContains();
const valid = validators.isMaxContains(mock);
assert.equal(valid, true);
});
test.skip("MinContains", () => {
const mock = mocks.mockMinContains();
const valid = validators.isMinContains(mock);
assert.equal(valid, true);
});
test.skip("MaxProperties", () => {
const mock = mocks.mockMaxProperties();
const valid = validators.isMaxProperties(mock);
assert.equal(valid, true);
});
test.skip("MinProperties", () => {
const mock = mocks.mockMinProperties();
const valid = validators.isMinProperties(mock);
assert.equal(valid, true);
});
test.skip("Required", () => {
const mock = mocks.mockRequired();
const valid = validators.isRequired(mock);
assert.equal(valid, true);
});
test.skip("DependentRequired", () => {
const mock = mocks.mockDependentRequired();
const valid = validators.isDependentRequired(mock);
assert.equal(valid, true);
});
test.skip("StringArrayItems", () => {
const mock = mocks.mockStringArrayItems();
const valid = validators.isStringArrayItems(mock);
assert.equal(valid, true);
});
test.skip("Type0", () => {
const mock = mocks.mockType0();
const valid = validators.isType0(mock);
assert.equal(valid, true);
});
test.skip("Type1", () => {
const mock = mocks.mockType1();
const valid = validators.isType1(mock);
assert.equal(valid, true);
});
test.skip("EnumItems", () => {
const mock = mocks.mockEnumItems();
const valid = validators.isEnumItems(mock);
assert.equal(valid, true);
});
test.skip("DependentRequiredAdditionalProperties", () => {
const mock = mocks.mockDependentRequiredAdditionalProperties();
const valid = validators.isDependentRequiredAdditionalProperties(mock);
assert.equal(valid, true);
});
test.skip("TypeItems", () => {
const mock = mocks.mockTypeItems();
const valid = validators.isTypeItems(mock);
assert.equal(valid, true);
});
test.skip("MetaData", () => {
const mock = mocks.mockMetaData();
const valid = validators.isMetaData(mock);
assert.equal(valid, true);
});
test.skip("Title", () => {
const mock = mocks.mockTitle();
const valid = validators.isTitle(mock);
assert.equal(valid, true);
});
test.skip("Description", () => {
const mock = mocks.mockDescription();
const valid = validators.isDescription(mock);
assert.equal(valid, true);
});
test.skip("Default", () => {
const mock = mocks.mockDefault();
const valid = validators.isDefault(mock);
assert.equal(valid, true);
});
test.skip("Deprecated", () => {
const mock = mocks.mockDeprecated();
const valid = validators.isDeprecated(mock);
assert.equal(valid, true);
});
test.skip("ReadOnly", () => {
const mock = mocks.mockReadOnly();
const valid = validators.isReadOnly(mock);
assert.equal(valid, true);
});
test.skip("WriteOnly", () => {
const mock = mocks.mockWriteOnly();
const valid = validators.isWriteOnly(mock);
assert.equal(valid, true);
});
test.skip("Examples", () => {
const mock = mocks.mockExamples();
const valid = validators.isExamples(mock);
assert.equal(valid, true);
});
test.skip("ExamplesItems", () => {
const mock = mocks.mockExamplesItems();
const valid = validators.isExamplesItems(mock);
assert.equal(valid, true);
});
test.skip("FormatAnnotation", () => {
const mock = mocks.mockFormatAnnotation();
const valid = validators.isFormatAnnotation(mock);
assert.equal(valid, true);
});
test.skip("Format", () => {
const mock = mocks.mockFormat();
const valid = validators.isFormat(mock);
assert.equal(valid, true);
});
test.skip("Content", () => {
const mock = mocks.mockContent();
const valid = validators.isContent(mock);
assert.equal(valid, true);
});
test.skip("ContentEncoding", () => {
const mock = mocks.mockContentEncoding();
const valid = validators.isContentEncoding(mock);
assert.equal(valid, true);
});
test.skip("ContentMediaType", () => {
const mock = mocks.mockContentMediaType();
const valid = validators.isContentMediaType(mock);
assert.equal(valid, true);
});
test.skip("ContentSchema", () => {
const mock = mocks.mockContentSchema();
const valid = validators.isContentSchema(mock);
assert.equal(valid, true);
});
