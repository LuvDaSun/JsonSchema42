// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.11.8                         -- www.JsonSchema42.org
//
import assert from "node:assert/strict";
import test from "node:test";
import * as validators from "./validators.js";
import * as mocks from "./mocks.js";
test("AnchorString", () => {
const mock = mocks.mockAnchorString();
const valid = validators.isAnchorString(mock);
assert.equal(valid, true);
});
test("UriReferenceString", () => {
const mock = mocks.mockUriReferenceString();
const valid = validators.isUriReferenceString(mock);
assert.equal(valid, true);
});
test("UriString", () => {
const mock = mocks.mockUriString();
const valid = validators.isUriString(mock);
assert.equal(valid, true);
});
test("Comment", () => {
const mock = mocks.mockComment();
const valid = validators.isComment(mock);
assert.equal(valid, true);
});
test("VocabularyAdditionalProperties", () => {
const mock = mocks.mockVocabularyAdditionalProperties();
const valid = validators.isVocabularyAdditionalProperties(mock);
assert.equal(valid, true);
});
test("PatternPropertiesPropertyNames", () => {
const mock = mocks.mockPatternPropertiesPropertyNames();
const valid = validators.isPatternPropertiesPropertyNames(mock);
assert.equal(valid, true);
});
test("NonNegativeInteger", () => {
const mock = mocks.mockNonNegativeInteger();
const valid = validators.isNonNegativeInteger(mock);
assert.equal(valid, true);
});
test("SimpleTypes", () => {
const mock = mocks.mockSimpleTypes();
const valid = validators.isSimpleTypes(mock);
assert.equal(valid, true);
});
test("MultipleOf", () => {
const mock = mocks.mockMultipleOf();
const valid = validators.isMultipleOf(mock);
assert.equal(valid, true);
});
test("Maximum", () => {
const mock = mocks.mockMaximum();
const valid = validators.isMaximum(mock);
assert.equal(valid, true);
});
test("ExclusiveMaximum", () => {
const mock = mocks.mockExclusiveMaximum();
const valid = validators.isExclusiveMaximum(mock);
assert.equal(valid, true);
});
test("Minimum", () => {
const mock = mocks.mockMinimum();
const valid = validators.isMinimum(mock);
assert.equal(valid, true);
});
test("ExclusiveMinimum", () => {
const mock = mocks.mockExclusiveMinimum();
const valid = validators.isExclusiveMinimum(mock);
assert.equal(valid, true);
});
test("Pattern", () => {
const mock = mocks.mockPattern();
const valid = validators.isPattern(mock);
assert.equal(valid, true);
});
test("UniqueItems", () => {
const mock = mocks.mockUniqueItems();
const valid = validators.isUniqueItems(mock);
assert.equal(valid, true);
});
test("StringArrayItems", () => {
const mock = mocks.mockStringArrayItems();
const valid = validators.isStringArrayItems(mock);
assert.equal(valid, true);
});
test("Title", () => {
const mock = mocks.mockTitle();
const valid = validators.isTitle(mock);
assert.equal(valid, true);
});
test("Description", () => {
const mock = mocks.mockDescription();
const valid = validators.isDescription(mock);
assert.equal(valid, true);
});
test("Deprecated", () => {
const mock = mocks.mockDeprecated();
const valid = validators.isDeprecated(mock);
assert.equal(valid, true);
});
test("ReadOnly", () => {
const mock = mocks.mockReadOnly();
const valid = validators.isReadOnly(mock);
assert.equal(valid, true);
});
test("WriteOnly", () => {
const mock = mocks.mockWriteOnly();
const valid = validators.isWriteOnly(mock);
assert.equal(valid, true);
});
test("Format", () => {
const mock = mocks.mockFormat();
const valid = validators.isFormat(mock);
assert.equal(valid, true);
});
test("ContentEncoding", () => {
const mock = mocks.mockContentEncoding();
const valid = validators.isContentEncoding(mock);
assert.equal(valid, true);
});
test("ContentMediaType", () => {
const mock = mocks.mockContentMediaType();
const valid = validators.isContentMediaType(mock);
assert.equal(valid, true);
});
