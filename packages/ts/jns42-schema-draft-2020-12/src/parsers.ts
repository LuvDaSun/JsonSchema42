// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.8.6                          -- www.JsonSchema42.org
export function parseDraft202012Schema(value: unknown): unknown {
return _parseMapDraft202012Schema(value) ?? _parseBooleanDraft202012Schema(value) ?? _parseAllOfDraft202012Schema(value);
}
function _parseMapDraft202012Schema(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "definitions": {
const propertyValue = parseDefinitions(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "dependencies": {
const propertyValue = parseDependencies(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$recursiveAnchor": {
const propertyValue = parseRecursiveAnchor(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$recursiveRef": {
const propertyValue = parseRecursiveRef(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanDraft202012Schema(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
function _parseAllOfDraft202012Schema(value: unknown): unknown {
return parseAllOf0(value) ?? parseAllOf1(value) ?? parseAllOf2(value) ?? parseAllOf3(value) ?? parseAllOf4(value) ?? parseAllOf5(value) ?? parseAllOf6(value);
}
export function parseDefinitions(value: unknown): unknown {
return _parseMapDefinitions(value);
}
function _parseMapDefinitions(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseDefinitionsAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseDependencies(value: unknown): unknown {
return _parseMapDependencies(value);
}
function _parseMapDependencies(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseDependenciesAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseRecursiveAnchor(value: unknown): unknown {
return _parseReferenceRecursiveAnchor(value);
}
function _parseReferenceRecursiveAnchor(value: unknown): unknown {
return parseAnchorString(value);
}
export function parseRecursiveRef(value: unknown): unknown {
return _parseReferenceRecursiveRef(value);
}
function _parseReferenceRecursiveRef(value: unknown): unknown {
return parseUriReferenceString(value);
}
export function parseAllOf0(value: unknown): unknown {
return _parseReferenceAllOf0(value);
}
function _parseReferenceAllOf0(value: unknown): unknown {
return parseCore(value);
}
export function parseAllOf1(value: unknown): unknown {
return _parseReferenceAllOf1(value);
}
function _parseReferenceAllOf1(value: unknown): unknown {
return parseApplicator(value);
}
export function parseAllOf2(value: unknown): unknown {
return _parseReferenceAllOf2(value);
}
function _parseReferenceAllOf2(value: unknown): unknown {
return parseUnevaluated(value);
}
export function parseAllOf3(value: unknown): unknown {
return _parseReferenceAllOf3(value);
}
function _parseReferenceAllOf3(value: unknown): unknown {
return parseValidation(value);
}
export function parseAllOf4(value: unknown): unknown {
return _parseReferenceAllOf4(value);
}
function _parseReferenceAllOf4(value: unknown): unknown {
return parseMetaData(value);
}
export function parseAllOf5(value: unknown): unknown {
return _parseReferenceAllOf5(value);
}
function _parseReferenceAllOf5(value: unknown): unknown {
return parseFormatAnnotation(value);
}
export function parseAllOf6(value: unknown): unknown {
return _parseReferenceAllOf6(value);
}
function _parseReferenceAllOf6(value: unknown): unknown {
return parseContent(value);
}
export function parseDefinitionsAdditionalProperties(value: unknown): unknown {
return _parseReferenceDefinitionsAdditionalProperties(value);
}
function _parseReferenceDefinitionsAdditionalProperties(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseDependenciesAdditionalProperties(value: unknown): unknown {
return _parseAnyOfDependenciesAdditionalProperties(value);
}
function _parseAnyOfDependenciesAdditionalProperties(value: unknown): unknown {
return parseAdditionalPropertiesAnyOf0(value) ?? parseAdditionalPropertiesAnyOf1(value);
}
export function parseAdditionalPropertiesAnyOf0(value: unknown): unknown {
return _parseReferenceAdditionalPropertiesAnyOf0(value);
}
function _parseReferenceAdditionalPropertiesAnyOf0(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseAdditionalPropertiesAnyOf1(value: unknown): unknown {
return _parseReferenceAdditionalPropertiesAnyOf1(value);
}
function _parseReferenceAdditionalPropertiesAnyOf1(value: unknown): unknown {
return parseStringArray(value);
}
export function parseAnchorString(value: unknown): unknown {
return _parseStringAnchorString(value);
}
function _parseStringAnchorString(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseUriReferenceString(value: unknown): unknown {
return _parseStringUriReferenceString(value);
}
function _parseStringUriReferenceString(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseCore(value: unknown): unknown {
return _parseMapCore(value) ?? _parseBooleanCore(value);
}
function _parseMapCore(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "$id": {
const propertyValue = parseId(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$schema": {
const propertyValue = parsePropertiesSchema(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$ref": {
const propertyValue = parseRef(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$anchor": {
const propertyValue = parseAnchor(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$dynamicRef": {
const propertyValue = parseDynamicRef(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$dynamicAnchor": {
const propertyValue = parseDynamicAnchor(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$vocabulary": {
const propertyValue = parseVocabulary(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$comment": {
const propertyValue = parseComment(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "$defs": {
const propertyValue = parseDefs(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanCore(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseUriString(value: unknown): unknown {
return _parseStringUriString(value);
}
function _parseStringUriString(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseId(value: unknown): unknown {
return _parseStringId(value) ?? _parseReferenceId(value);
}
function _parseStringId(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
function _parseReferenceId(value: unknown): unknown {
return parseUriReferenceString(value);
}
export function parsePropertiesSchema(value: unknown): unknown {
return _parseReferencePropertiesSchema(value);
}
function _parseReferencePropertiesSchema(value: unknown): unknown {
return parseUriString(value);
}
export function parseRef(value: unknown): unknown {
return _parseReferenceRef(value);
}
function _parseReferenceRef(value: unknown): unknown {
return parseUriReferenceString(value);
}
export function parseAnchor(value: unknown): unknown {
return _parseReferenceAnchor(value);
}
function _parseReferenceAnchor(value: unknown): unknown {
return parseAnchorString(value);
}
export function parseDynamicRef(value: unknown): unknown {
return _parseReferenceDynamicRef(value);
}
function _parseReferenceDynamicRef(value: unknown): unknown {
return parseUriReferenceString(value);
}
export function parseDynamicAnchor(value: unknown): unknown {
return _parseReferenceDynamicAnchor(value);
}
function _parseReferenceDynamicAnchor(value: unknown): unknown {
return parseAnchorString(value);
}
export function parseVocabulary(value: unknown): unknown {
return _parseMapVocabulary(value);
}
function _parseMapVocabulary(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseVocabularyPropertyNames(value[propertyName as keyof typeof value]);
result[propertyName] ??= parseVocabularyAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseComment(value: unknown): unknown {
return _parseStringComment(value);
}
function _parseStringComment(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseDefs(value: unknown): unknown {
return _parseMapDefs(value);
}
function _parseMapDefs(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseDefsAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseVocabularyAdditionalProperties(value: unknown): unknown {
return _parseBooleanVocabularyAdditionalProperties(value);
}
function _parseBooleanVocabularyAdditionalProperties(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseVocabularyPropertyNames(value: unknown): unknown {
return _parseReferenceVocabularyPropertyNames(value);
}
function _parseReferenceVocabularyPropertyNames(value: unknown): unknown {
return parseUriString(value);
}
export function parseDefsAdditionalProperties(value: unknown): unknown {
return _parseReferenceDefsAdditionalProperties(value);
}
function _parseReferenceDefsAdditionalProperties(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseApplicator(value: unknown): unknown {
return _parseMapApplicator(value) ?? _parseBooleanApplicator(value);
}
function _parseMapApplicator(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "prefixItems": {
const propertyValue = parsePrefixItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "items": {
const propertyValue = parsePropertiesItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "contains": {
const propertyValue = parseContains(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "additionalProperties": {
const propertyValue = parseApplicatorPropertiesAdditionalProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "properties": {
const propertyValue = parseProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "patternProperties": {
const propertyValue = parsePatternProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "dependentSchemas": {
const propertyValue = parseDependentSchemas(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "propertyNames": {
const propertyValue = parsePropertiesPropertyNames(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "if": {
const propertyValue = parseIf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "then": {
const propertyValue = parseThen(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "else": {
const propertyValue = parseElse(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "allOf": {
const propertyValue = parseAllOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "anyOf": {
const propertyValue = parseAnyOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "oneOf": {
const propertyValue = parseOneOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "not": {
const propertyValue = parseNot(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanApplicator(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseSchemaArray(value: unknown): unknown {
return _parseArraySchemaArray(value);
}
function _parseArraySchemaArray(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseSchemaArrayItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parsePrefixItems(value: unknown): unknown {
return _parseReferencePrefixItems(value);
}
function _parseReferencePrefixItems(value: unknown): unknown {
return parseSchemaArray(value);
}
export function parsePropertiesItems(value: unknown): unknown {
return _parseReferencePropertiesItems(value);
}
function _parseReferencePropertiesItems(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseContains(value: unknown): unknown {
return _parseReferenceContains(value);
}
function _parseReferenceContains(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseApplicatorPropertiesAdditionalProperties(value: unknown): unknown {
return _parseReferenceApplicatorPropertiesAdditionalProperties(value);
}
function _parseReferenceApplicatorPropertiesAdditionalProperties(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseProperties(value: unknown): unknown {
return _parseMapProperties(value);
}
function _parseMapProperties(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parsePropertiesPropertiesAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parsePatternProperties(value: unknown): unknown {
return _parseMapPatternProperties(value);
}
function _parseMapPatternProperties(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parsePatternPropertiesPropertyNames(value[propertyName as keyof typeof value]);
result[propertyName] ??= parsePatternPropertiesAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseDependentSchemas(value: unknown): unknown {
return _parseMapDependentSchemas(value);
}
function _parseMapDependentSchemas(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseDependentSchemasAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parsePropertiesPropertyNames(value: unknown): unknown {
return _parseReferencePropertiesPropertyNames(value);
}
function _parseReferencePropertiesPropertyNames(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseIf(value: unknown): unknown {
return _parseReferenceIf(value);
}
function _parseReferenceIf(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseThen(value: unknown): unknown {
return _parseReferenceThen(value);
}
function _parseReferenceThen(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseElse(value: unknown): unknown {
return _parseReferenceElse(value);
}
function _parseReferenceElse(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseAllOf(value: unknown): unknown {
return _parseReferenceAllOf(value);
}
function _parseReferenceAllOf(value: unknown): unknown {
return parseSchemaArray(value);
}
export function parseAnyOf(value: unknown): unknown {
return _parseReferenceAnyOf(value);
}
function _parseReferenceAnyOf(value: unknown): unknown {
return parseSchemaArray(value);
}
export function parseOneOf(value: unknown): unknown {
return _parseReferenceOneOf(value);
}
function _parseReferenceOneOf(value: unknown): unknown {
return parseSchemaArray(value);
}
export function parseNot(value: unknown): unknown {
return _parseReferenceNot(value);
}
function _parseReferenceNot(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseSchemaArrayItems(value: unknown): unknown {
return _parseReferenceSchemaArrayItems(value);
}
function _parseReferenceSchemaArrayItems(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parsePropertiesPropertiesAdditionalProperties(value: unknown): unknown {
return _parseReferencePropertiesPropertiesAdditionalProperties(value);
}
function _parseReferencePropertiesPropertiesAdditionalProperties(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parsePatternPropertiesAdditionalProperties(value: unknown): unknown {
return _parseReferencePatternPropertiesAdditionalProperties(value);
}
function _parseReferencePatternPropertiesAdditionalProperties(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parsePatternPropertiesPropertyNames(value: unknown): unknown {
return _parseStringPatternPropertiesPropertyNames(value);
}
function _parseStringPatternPropertiesPropertyNames(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseDependentSchemasAdditionalProperties(value: unknown): unknown {
return _parseReferenceDependentSchemasAdditionalProperties(value);
}
function _parseReferenceDependentSchemasAdditionalProperties(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseUnevaluated(value: unknown): unknown {
return _parseMapUnevaluated(value) ?? _parseBooleanUnevaluated(value);
}
function _parseMapUnevaluated(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "unevaluatedItems": {
const propertyValue = parseUnevaluatedItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "unevaluatedProperties": {
const propertyValue = parseUnevaluatedProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanUnevaluated(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseUnevaluatedItems(value: unknown): unknown {
return _parseReferenceUnevaluatedItems(value);
}
function _parseReferenceUnevaluatedItems(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseUnevaluatedProperties(value: unknown): unknown {
return _parseReferenceUnevaluatedProperties(value);
}
function _parseReferenceUnevaluatedProperties(value: unknown): unknown {
return parseDraft202012Schema(value);
}
export function parseValidation(value: unknown): unknown {
return _parseMapValidation(value) ?? _parseBooleanValidation(value);
}
function _parseMapValidation(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "type": {
const propertyValue = parseType(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "const": {
const propertyValue = parseConst(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "enum": {
const propertyValue = parseEnum(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "multipleOf": {
const propertyValue = parseMultipleOf(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maximum": {
const propertyValue = parseMaximum(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "exclusiveMaximum": {
const propertyValue = parseExclusiveMaximum(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minimum": {
const propertyValue = parseMinimum(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "exclusiveMinimum": {
const propertyValue = parseExclusiveMinimum(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maxLength": {
const propertyValue = parseMaxLength(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minLength": {
const propertyValue = parseMinLength(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "pattern": {
const propertyValue = parsePattern(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maxItems": {
const propertyValue = parseMaxItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minItems": {
const propertyValue = parseMinItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "uniqueItems": {
const propertyValue = parseUniqueItems(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maxContains": {
const propertyValue = parseMaxContains(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minContains": {
const propertyValue = parseMinContains(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "maxProperties": {
const propertyValue = parseMaxProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "minProperties": {
const propertyValue = parseMinProperties(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "required": {
const propertyValue = parseRequired(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "dependentRequired": {
const propertyValue = parseDependentRequired(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanValidation(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseNonNegativeInteger(value: unknown): unknown {
return _parseIntegerNonNegativeInteger(value);
}
function _parseIntegerNonNegativeInteger(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseNonNegativeIntegerDefault0(value: unknown): unknown {
return _parseReferenceNonNegativeIntegerDefault0(value);
}
function _parseReferenceNonNegativeIntegerDefault0(value: unknown): unknown {
return parseNonNegativeInteger(value);
}
export function parseSimpleTypes(value: unknown): unknown {
return _parseStringSimpleTypes(value);
}
function _parseStringSimpleTypes(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseStringArray(value: unknown): unknown {
return _parseArrayStringArray(value);
}
function _parseArrayStringArray(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseStringArrayItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseType(value: unknown): unknown {
return _parseAnyOfType(value);
}
function _parseAnyOfType(value: unknown): unknown {
return parseTypeAnyOf0(value) ?? parseTypeAnyOf1(value);
}
export function parseConst(value: unknown): unknown {
return _parseAnyConst(value);
}
function _parseAnyConst(value: unknown): unknown {
return value;
}
export function parseEnum(value: unknown): unknown {
return _parseArrayEnum(value);
}
function _parseArrayEnum(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseEnumItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseMultipleOf(value: unknown): unknown {
return _parseNumberMultipleOf(value);
}
function _parseNumberMultipleOf(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseMaximum(value: unknown): unknown {
return _parseNumberMaximum(value);
}
function _parseNumberMaximum(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseExclusiveMaximum(value: unknown): unknown {
return _parseNumberExclusiveMaximum(value);
}
function _parseNumberExclusiveMaximum(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseMinimum(value: unknown): unknown {
return _parseNumberMinimum(value);
}
function _parseNumberMinimum(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseExclusiveMinimum(value: unknown): unknown {
return _parseNumberExclusiveMinimum(value);
}
function _parseNumberExclusiveMinimum(value: unknown): unknown {
switch(typeof value) {
case "string":
return Number(value);
case "number":
return value;
case "boolean":
return value ? 1 : 0;
}
return undefined;
}
export function parseMaxLength(value: unknown): unknown {
return _parseReferenceMaxLength(value);
}
function _parseReferenceMaxLength(value: unknown): unknown {
return parseNonNegativeInteger(value);
}
export function parseMinLength(value: unknown): unknown {
return _parseReferenceMinLength(value);
}
function _parseReferenceMinLength(value: unknown): unknown {
return parseNonNegativeIntegerDefault0(value);
}
export function parsePattern(value: unknown): unknown {
return _parseStringPattern(value);
}
function _parseStringPattern(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseMaxItems(value: unknown): unknown {
return _parseReferenceMaxItems(value);
}
function _parseReferenceMaxItems(value: unknown): unknown {
return parseNonNegativeInteger(value);
}
export function parseMinItems(value: unknown): unknown {
return _parseReferenceMinItems(value);
}
function _parseReferenceMinItems(value: unknown): unknown {
return parseNonNegativeIntegerDefault0(value);
}
export function parseUniqueItems(value: unknown): unknown {
return _parseBooleanUniqueItems(value);
}
function _parseBooleanUniqueItems(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseMaxContains(value: unknown): unknown {
return _parseReferenceMaxContains(value);
}
function _parseReferenceMaxContains(value: unknown): unknown {
return parseNonNegativeInteger(value);
}
export function parseMinContains(value: unknown): unknown {
return _parseReferenceMinContains(value);
}
function _parseReferenceMinContains(value: unknown): unknown {
return parseNonNegativeInteger(value);
}
export function parseMaxProperties(value: unknown): unknown {
return _parseReferenceMaxProperties(value);
}
function _parseReferenceMaxProperties(value: unknown): unknown {
return parseNonNegativeInteger(value);
}
export function parseMinProperties(value: unknown): unknown {
return _parseReferenceMinProperties(value);
}
function _parseReferenceMinProperties(value: unknown): unknown {
return parseNonNegativeIntegerDefault0(value);
}
export function parseRequired(value: unknown): unknown {
return _parseReferenceRequired(value);
}
function _parseReferenceRequired(value: unknown): unknown {
return parseStringArray(value);
}
export function parseDependentRequired(value: unknown): unknown {
return _parseMapDependentRequired(value);
}
function _parseMapDependentRequired(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
result[propertyName] ??= parseDependentRequiredAdditionalProperties(value[propertyName as keyof typeof value]);
}
return result;
}
return undefined;
}
export function parseStringArrayItems(value: unknown): unknown {
return _parseStringStringArrayItems(value);
}
function _parseStringStringArrayItems(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseTypeAnyOf0(value: unknown): unknown {
return _parseReferenceTypeAnyOf0(value);
}
function _parseReferenceTypeAnyOf0(value: unknown): unknown {
return parseSimpleTypes(value);
}
export function parseTypeAnyOf1(value: unknown): unknown {
return _parseArrayTypeAnyOf1(value);
}
function _parseArrayTypeAnyOf1(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseAnyOf1Items(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseEnumItems(value: unknown): unknown {
return _parseAnyEnumItems(value);
}
function _parseAnyEnumItems(value: unknown): unknown {
return value;
}
export function parseDependentRequiredAdditionalProperties(value: unknown): unknown {
return _parseReferenceDependentRequiredAdditionalProperties(value);
}
function _parseReferenceDependentRequiredAdditionalProperties(value: unknown): unknown {
return parseStringArray(value);
}
export function parseAnyOf1Items(value: unknown): unknown {
return _parseReferenceAnyOf1Items(value);
}
function _parseReferenceAnyOf1Items(value: unknown): unknown {
return parseSimpleTypes(value);
}
export function parseMetaData(value: unknown): unknown {
return _parseMapMetaData(value) ?? _parseBooleanMetaData(value);
}
function _parseMapMetaData(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "title": {
const propertyValue = parseTitle(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "description": {
const propertyValue = parseDescription(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "default": {
const propertyValue = parseDefault(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "deprecated": {
const propertyValue = parseDeprecated(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "readOnly": {
const propertyValue = parseReadOnly(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "writeOnly": {
const propertyValue = parseWriteOnly(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "examples": {
const propertyValue = parseExamples(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanMetaData(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseTitle(value: unknown): unknown {
return _parseStringTitle(value);
}
function _parseStringTitle(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseDescription(value: unknown): unknown {
return _parseStringDescription(value);
}
function _parseStringDescription(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseDefault(value: unknown): unknown {
return _parseAnyDefault(value);
}
function _parseAnyDefault(value: unknown): unknown {
return value;
}
export function parseDeprecated(value: unknown): unknown {
return _parseBooleanDeprecated(value);
}
function _parseBooleanDeprecated(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseReadOnly(value: unknown): unknown {
return _parseBooleanReadOnly(value);
}
function _parseBooleanReadOnly(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseWriteOnly(value: unknown): unknown {
return _parseBooleanWriteOnly(value);
}
function _parseBooleanWriteOnly(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseExamples(value: unknown): unknown {
return _parseArrayExamples(value);
}
function _parseArrayExamples(value: unknown): unknown {
if(Array.isArray(value)) {
const result = new Array<unknown>(value.length);
for(let elementIndex = 0; elementIndex < value.length; elementIndex++) {
result[elementIndex] = parseExamplesItems(value[elementIndex]);
}
return result;
}
return undefined;
}
export function parseExamplesItems(value: unknown): unknown {
return _parseAnyExamplesItems(value);
}
function _parseAnyExamplesItems(value: unknown): unknown {
return value;
}
export function parseFormatAnnotation(value: unknown): unknown {
return _parseMapFormatAnnotation(value) ?? _parseBooleanFormatAnnotation(value);
}
function _parseMapFormatAnnotation(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "format": {
const propertyValue = parseFormat(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanFormatAnnotation(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseFormat(value: unknown): unknown {
return _parseStringFormat(value);
}
function _parseStringFormat(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseContent(value: unknown): unknown {
return _parseMapContent(value) ?? _parseBooleanContent(value);
}
function _parseMapContent(value: unknown): unknown {
if(typeof value === "object" && value !== null && !Array.isArray(value)) {
const result = {} as Record<string, unknown>;
for(const propertyName in value) {
switch(propertyName) {
case "contentEncoding": {
const propertyValue = parseContentEncoding(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "contentMediaType": {
const propertyValue = parseContentMediaType(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
case "contentSchema": {
const propertyValue = parseContentSchema(value[propertyName as keyof typeof value]);
result[propertyName] = propertyValue;
break;
}
}
}
return result;
}
return undefined;
}
function _parseBooleanContent(value: unknown): unknown {
if(value == null) {
return false;
}
switch(typeof value) {
case "string":
switch(value.trim()) {
case "":
case "no":
case "off":
case "false":
case "0":
return false;
default:
return true;
}
case "number":
return Boolean(value);
case "boolean":
return value;
}
return undefined;
}
export function parseContentEncoding(value: unknown): unknown {
return _parseStringContentEncoding(value);
}
function _parseStringContentEncoding(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseContentMediaType(value: unknown): unknown {
return _parseStringContentMediaType(value);
}
function _parseStringContentMediaType(value: unknown): unknown {
switch(typeof value) {
case "string":
return value;
case "number":
case "boolean":
return String(value);
default:
return undefined;
}
}
export function parseContentSchema(value: unknown): unknown {
return _parseReferenceContentSchema(value);
}
function _parseReferenceContentSchema(value: unknown): unknown {
return parseDraft202012Schema(value);
}
